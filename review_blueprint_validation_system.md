# Ревью архитектуры системы валидации Blueprint / content_json

Ниже перечислены архитектурные недостатки текущего решения и предложения по их улучшению.

---

## 1. Сильная привязка домена к Laravel-валидации

**Недостаток**  
`BlueprintContentValidator` и `PathValidationRulesConverter` напрямую завязаны на формат правил Laravel (`string|min:1|max:10|regex:/.../`).  
Доменные сущности (`Blueprint`, `Path`) сразу используются как генератор Laravel-правил.

**Чем чревато**  
Сложно использовать тот же Blueprint для:
- валидации на фронте (JSON schema, Zod и т.п.),
- асинхронных пайплайнов, CLI-скриптов, других сервисов (не на Laravel),
- смены валидатора или фреймворка.

**Предложение**
- Ввести доменную модель правил (например, `Rule`, `RuleSet`, `FieldDefinition`), не зависящую от Laravel.
- Сделать адаптер: _DomainRuleSet → LaravelValidationRules_ отдельным слоем.
- `BlueprintContentValidator` пусть оперирует доменными правилами, а HTTP-слой уже маппит их в формат Laravel.

---

## 2. Статический `PathValidationRulesConverter`

**Недостаток**  
Класс полностью статический: `PathValidationRulesConverter::convert(...)`. Расширение/подмена логики возможно только через редактирование самого класса.

**Чем чревато**
- Невозможна нормальная DI/подмена реализации.
- Тестирование усложняется — нельзя подменить конвертер мок-объектом.
- Любые кастомные правила превращаются в «ифы» внутри одного монолитного конвертера.

**Предложение**
- Сделать конвертер сервисом: `PathValidationRulesConverterInterface` + реализация.
- Поддержать расширения через конфигурацию/плагины:
  - registry `dataType → ruleBuilder`,
  - registry `validationRuleKey → handler`.
- Новые типы правил/данных добавлять без изменения базового класса.

---

## 3. Логика валидации утекла в HTTP-слой (FormRequest)

**Недостаток**  
Точка сборки правил — в `StoreEntryRequest::withValidator()` / `UpdateEntryRequest::withValidator()`. HTTP-слой знает и про поиск `PostType`/`Entry`, и про `Blueprint`, и про построение правил.

**Чем чревато**
- Валидация привязана к конкретным HTTP-запросам.
- Сложнее переиспользовать валидацию в консольных командах, очередях, других API/GraphQL.

**Предложение**
- Вынести валидацию в отдельный доменный сервис, например:
  - `EntryValidationService::buildRulesFor(Blueprint $bp): RuleSet`,
  - `EntryValidationService::validate(Blueprint $bp, array $content): ValidationResult`.
- FormRequest только находит нужный `Blueprint` и маппит результат в Laravel Validator.

---

## 4. Ограниченная выразительность правил

**Недостаток**  
`validation_rules` Path поддерживает только базовые параметры: `min`, `max`, `pattern`.  
Нет встроенной поддержки:
- условных правил (`required_if`, `prohibited_unless`, и т.п.),
- межполейных зависимостей (A ≥ B, XOR, и т.д.),
- уникальности (`unique`), существования (`exists`),
- сложных кастомных валидаторов.

**Чем чревато**
- Blueprint описывает только «плоскую» валидацию.
- Сложные бизнес-инварианты вынесены из Blueprint в отдельный код, и «источник правды» расползается.

**Предложение**
- Расширить модель `validation_rules` типизированными правилами: `type`, `operator`, `params`.
- Ввести схему зависимостей между путями (`depends_on`, `condition`).
- Добавить уровень обработчиков правил:
  - `MinRuleHandler`, `MaxRuleHandler`, `PatternRuleHandler`, `ConditionalRuleHandler` и т.п.
- Laravel-адаптер маппит доменные правила в строки для Validator.

---

## 5. Кэширование по `blueprint_id` без версионирования

**Недостаток**  
Ключ кэша: `blueprint:validation_rules:{id}`.  
Используется событие `BlueprintStructureChanged` для инвалидации, но нет понятия версии Blueprint.

**Чем чревато**
- Смена Blueprint ломает историю: старые Entry создавались по старым правилам, но при обновлении валидируются по новым.
- Нельзя одновременно поддерживать новый и старый варианты Blueprint для разных Entry.

**Предложение**
- Ввести версионирование Blueprint:
  - `blueprint_id` + `version`,
  - хранить версию в Entry.
- Кэшировать по ключу `blueprint:validation_rules:{id}:{version}`.
- При изменении структуры создавать новую версию, а не перетирать существующую.

---

## 6. Кэширование завязано на одно событие и одну реализацию

**Недостаток**  
Инвалидация кэша жёстко привязана к событию `BlueprintStructureChanged` и конкретному `InvalidateValidationCache`, который вызывает метод `invalidateCache` у определённого валидатора.

**Чем чревато**
- При появлении второй реализации валидатора/кэша их придётся помнить и обслуживать вручную.
- Доменное событие и техническая реакция слиплись.

**Предложение**
- Оставить событие доменным (`BlueprintStructureChanged`), но сделать архитектуру подписок более гибкой:
  - `InvalidateValidationCache`,
  - `WarmUpValidationCache`,
  - `NotifySearchIndexer` и т.п.
- Слушатель работает с кэш-слоем напрямую, а не с конкретным валидатором.

---

## 7. Модель `Path` основана на строковом `full_path`

**Недостаток**  
Структура полей описана строкой `full_path` (`"blocks.0.title"` и т.п.), генерация ключей идёт через конкатенацию строк.

**Чем чревато**
- Хрупкость при изменении нейминга и иерархии.
- Сложно делать рефакторинг структуры (переименование полей, перемещение поддеревьев).
- Трудно оптимизировать работу с поддеревьями при глубокой вложенности.

**Предложение**
- Хранить путь структурированно (массив сегментов, дерево, nested set).
- `full_path` делать вычисляемым/кэшируемым полем, а не «источником истины».
- Генерацию правил строить от дерева — проще поддерживать операции с поддеревьями и сложные ограничения.

---

## 8. Валидация Entry жёстко завязана на `post_type`/`entryId` в запросе

**Недостаток**  
Контекст валидации определяется полями HTTP-запроса (`post_type` или `entryId`), а логика поиска Blueprint сидит рядом с валидацией.

**Чем чревато**
- Сложно переиспользовать ту же систему в другом контексте, где контекст определяется иначе.
- Высокая связанность между API-контрактом и доменной логикой.

**Предложение**
- Отделить «поиск Blueprint» от «валидации по Blueprint» через контекст-резолвер, например:
  - `BlueprintContextResolver::resolveFromRequest(Request): Blueprint`.
- Валидация работает только с найденным Blueprint и данными.

---

## 9. Ошибки валидации не имеют доменной семантики

**Недостаток**  
Ошибки возвращаются в виде стандартных Laravel-сообщений `field => [message]` без доменных кодов.

**Чем чревато**
- Фронтенд и внешние системы видят только текст сообщений и не знают, к какому Path и какому правилу он относится.
- Сложнее локализовывать сообщения на клиенте и строить умный UI вокруг ошибок.

**Предложение**
- В доменную модель правил добавить код правила (`BLUEPRINT_REQUIRED`, `BLUEPRINT_MIN_LENGTH` и т.п.).
- В ответе отдавать структурированные данные об ошибках:
  - `path_id`, `rule_code`, `params`.
- Фронтенд может сам собирать сообщения и тултипы, а тексты вынести в отдельный слой локализации.

---

## 10. `cardinality` покрывает только `one` / `many` на уровне массива

**Недостаток**  
`cardinality` описывает только массив/не массив. Нет поддержки:
- ограничений на размер массива (`min_items`, `max_items`),
- уникальности значений внутри массива,
- сложной структуры элементов массива (например, разные правила в зависимости от индекса или типа элемента).

**Чем чревато**
- Для сложных повторяющихся блоков (галереи, секции страницы) возможности описания ограничены.
- Нельзя в Blueprint задать требования «не более N элементов», «хотя бы один элемент такого типа» и т.п.

**Предложение**
- Расширить модель `cardinality` и правила для массивов:
  - `min_items`, `max_items`, `unique`, `item_validation` и др.
- Ввести понятие «тип элемента массива»:
  - через вложенный Blueprint или ссылку на поддерево Path.
