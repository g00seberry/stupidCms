+Ввести MediaRepository/QueryObject для инкапсуляции фильтров, сортировок и soft delete логики из MediaController@index, чтобы HTTP, CLI и background‑таски переиспользовали единый контракт.

+Разделить ответственность MediaController на CQRS‑подобные обработчики (ListMediaAction, UpdateMediaMetadataAction и т. д.) и использовать их в контроллере, уменьшая дублирование и упрощая тесты.

+Перевести генерацию вариантов в асинхронный pipeline: заменить dispatchSync на очереди, добавить статус поля в media_variants, ретраи и идемпотентность, чтобы тяжёлые операции уходили в workers.

Сконфигурировать Worker API: описать очереди/приоритеты для GenerateVariantJob, внедрить rate limiting и мониторинг (например, через Horizon), чтобы управлять ресурсами конвертации.

+Абстрагировать обработку изображений: заменить прямые вызовы GD на интерфейс (например, ImageProcessor), позволяющий подменять на Imagick, Glide или внешние сервисы, повышая качество и поддерживая HEIC/AVIF.

+Расширить MediaMetadataExtractor плагинами для ffprobe/mediainfo, чтобы извлекать длительность, битрейт и кадры для видео/аудио и сохранять normalize‑данные в новых колонках.

Создать схему конфигурации вариантов (JSON Schema + кастомная валидация), включающую поля format, quality, fit, background, watermark, и хранить текущую версию в БД для future reprocessing.

Реализовать управление жизненным циклом: добавить таблицу media_usages, чтобы перед delete/restore контроллер мог проверять, используется ли файл, и обеспечивать каскадное обновление.

+Ввести событийную модель (MediaUploaded, MediaProcessed, MediaDeleted) и слушателей для логирования, уведомлений и автоматических интеграций (CDN purge).

Отделить маршруты публичного доступа: предоставить /media/{id} с короткими подписанными URL (TTL из config), чтобы клиентам не требовалась админ‑аутентификация.

+Добавить CDN/storage абстракцию: расширить config до нескольких дисков по коллекциям, внедрив StorageResolver (например, S3 для видео, локальный для документов).

Поддержать chunked/resumable uploads: реализовать отдельный endpoint и state machine в MediaStoreAction для файлов > MEDIA_MAX_UPLOAD_MB, сохраняя временные части и консолидируя checksum post factum.

Сделать reprocessing сервис: action, который переиндексирует метаданные/варианты при изменении конфигурации, с очередями и throttling, управляемый из админки и защищённый политикой reprocess.

Моделировать preview/download URLs как value objects: вместо генерации строк в MediaResource вернуть объект с TTL, подписью и CDN host, чтобы позже можно было внедрить signed URLs и revoke‑механику.

Добавить аудит и квоты: вести счётчик суммарного объёма по пользователю/коллекции, логировать операции (upload/delete) и экспонировать в админке; пригодится для биллинга и контроля диска.

Укрепить валидацию входных данных: обогатить StoreMediaRequest и UpdateMediaRequest проверками длины title/alt, набора коллекций и автоматическим slugify, чтобы очищать данные на границе.

Нормализовать атрибуты в БД: вынести большие поля (exif_json, metadata) в отдельную таблицу или JSONB колонку, индексировать checksum_sha256, добавить ограничения уникальности по (disk,path).

Встроить контроль безопасности: автоматическая проверка вредоносных файлов (ClamAV/Threat API) перед сохранением и сохранение статуса проверки в БД; блокировать скачивание до прохождения сканирования.

Создать адаптеры импорта/экспорта: сервисы для миграции медиа между окружениями/дисками с валидацией checksum и пересозданием вариантов, чтобы масштабировать систему и проводить бэкапы.

Обновить документацию и тесты: расширить docs/media-system.md сценариями жизненного цикла, добавить нагрузочные/интеграционные тесты (queue, CDN, chunked uploads) и обеспечить автоматическую генерацию OpenAPI для новых endpoints.
