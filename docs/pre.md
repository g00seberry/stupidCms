Цель системы

Построить систему, где URL entry формируется из дерева узлов + leaf-слага entry, чтобы:

структурные сегменты (level1/level2/...) жили отдельно от entry;

переименование/перемещение разделов не требовало правки сотен entry;

конфликт системных путей и контента был исключён;

плагины и API гарантированно не перехватывались контентным catch-all;

можно было централизованно управлять структурой сайта.

Обратная совместимость со старым плоским /{slug} не требуется.

Архитектурные принципы

Детерминированный порядок роутов должен сохраниться

Core web

Public API

Admin API

Plugins

Content (catch-all)

Fallback

Контентный роут всегда последним перед fallback

Он должен быть максимально “широким”, но строго защищённым reserved-логикой.

Reserved paths — единый источник правды

И для regex-ограничений роутов,

и для runtime middleware-проверок,

и для валидации в админке.

Canonical URL

Нормализация URL должна работать до маршрутизации и для многоуровневых путей.

Терминология

RouteNode — узел дерева маршрутов.

Folder node — раздел/папка.

Entry node — лист дерева, связанный с конкретной entry.

Path — полный путь узла (цепочка parent.slug).

Leaf slug — slug entry-узла (последний сегмент).

Модель данных

1. Таблица route_nodes

Минимально необходимая схема:

id (PK)

parent_id (nullable, FK на route_nodes.id)

type enum: folder, entry

slug (строка одного сегмента)

title (человеческое имя)

entry_id (nullable, FK на entries.id)

is_published boolean

sort integer

created_at, updated_at

Ограничения

slug не содержит /

slug нормализуется в lowercase

уникальность в пределах родителя:

уникальный индекс (parent_id, slug)

уникальность связи entry:

если у entry должен быть ровно один node:

уникальный индекс на entry_id (где type = entry)

запрет циклов parent-child на уровне бизнес-логики.

2. Таблица route_redirects (рекомендуется оставить)

Даже без обратной совместимости это полезно для будущих переименований:

id

old_path (уникальный)

new_node_id (FK) или new_path (строка)

http_code (301 по умолчанию)

created_at

Если вы принципиально не хотите хранить редиректы вообще — этот слой можно отключить флагом, но практика показывает, что при жизни проекта они спасают.

Базовые правила маршрутизации

Полный URL entry формируется как:

/{folder1}/{folder2}/.../{entry_slug}

Где:

folder\* — slug’и folder-узлов по цепочке.

entry_slug — slug entry-узла.

У entry нет собственного pathSlug в данных.

Она ссылается на свой RouteNode типа entry.

Изменение slug у folder-узла влияет на весь поддерев автоматически.

Сервисы доменной логики

1. RoutePathBuilder

Задачи:

строит full_path узла по parent-chain:

для folder: /a/b/c

для entry-node: /a/b/c/entry

умеет отдавать:

segments[]

first_segment

full_path

Опции реализации:

вычисление “на лету” + кэш

либо хранение materialized_path (например, path_cache) в таблице и обновление при изменениях.

Это ускоряет массовые операции, но усложняет консистентность.

Рекомендация:

начать с вычисления + кэш уровня приложения,

при больших объёмах перейти к материализации.

2. RouteTreeService

Операции:

создать folder

переименовать узел

переместить узел

изменить sort

массовая публикация/скрытие ветки

создать entry-node для entry

переместить entry-node между папками

Это сервис “единого входа”, чтобы не расползалась логика по контроллерам.

3. RouteResolver

Задачи:

принимает входящий path (без leading /, нормализованный)

разбивает на сегменты

идёт по дереву:

ищет папки

затем entry-node

возвращает:

найденный RouteNode

связанную entry (если это entry-node)

или null

Отдельно:

resolveByPath(string $path)

resolveFolder(string $path)

resolveEntry(string $path)

4. RouteRedirectService

Если редиректы включены:

onNodeChanged(old_path, new_path)

создание записи route_redirects

контроль уникальности

политики:

создавать редирект всегда

создавать только при опубликованных узлах

отключаемо флагом

5. PathReservationService (используем существующий)

Должен уметь:

проверить “первый сегмент”

проверить конкретный path

дать список reserved первых сегментов

Reserved paths: расширение на multi-level

Нужно гарантировать:

контент не сможет использовать системные префиксы на первом уровне:

api, admin, assets, plugins, и др. ваши системные сегменты

при регистрации plugin web routes их префиксы также должны быть зарезервированы.

Обязательные места проверки:

Валидация slug при создании root-level folder.

Middleware на контентном catch-all:

вычленяет первый сегмент и отклоняет, если reserved.

Regex-ограничение в самом контентном маршруте:

negative lookahead на первый сегмент.

Это не заменяет middleware, но снижает риск ошибок и улучшает читаемость поведения.

Canonical URL

Расширить нормализацию так, чтобы она работала для:

/A/B/Entry/ → /a/b/entry

убирание лишних /

trailing slash политика единая (например, всегда без / в конце)

Важно, чтобы canonical middleware:

не ломал API и admin;

не конфликтовал с plugin namespaces.

Изменения в публичном роутинге

1. web_content.php

Удаляем старое плоское GET /{slug}.

Добавляем новый:

GET /{path}

где path match для многосегментных путей

с regex-ограничением “первый сегмент не reserved”

middleware:

web

RejectReservedIfMatched (адаптированный под multi-level)

ваш контентный middleware stack

Внутри контроллера:

берём path

нормализуем (если canonical не сделал всё)

RouteResolver->resolveByPath($path)

если найден entry-node → отдаём entry

если найден folder-node и у вас есть concept “folder page” → отдаём страницу раздела (опционально)

иначе 404

2. Fallback

Оставляем архитектурно как есть:

fallback не должен быть под web

отдельная обработка методов кроме GET/HEAD остаётся корректной.

Плагины

Правила:

Любой plugin web prefix должен быть:

зарезервирован как первый сегмент, если он находится на верхнем уровне

или иметь чёткий системный namespace.

Порядок регистрации:

plugin routes всё ещё регистрируются до content.

При добавлении нового plugin:

автоматическая регистрация резервации при установке/активации.

Admin API (управление деревом)

Рекомендуемые эндпоинты:

Дерево

GET /admin/route-nodes/tree

возвращает всё дерево или с lazy-load

POST /admin/route-nodes/folder

создать folder под parent

PATCH /admin/route-nodes/{id}

изменить title, slug, is_published

POST /admin/route-nodes/{id}/move

новый parent_id + sort

POST /admin/route-nodes/{id}/reorder

массовый reorder в пределах parent

DELETE /admin/route-nodes/{id}

политика удаления:

запрет, если есть children

или каскадное удаление с подтверждением (лучше запретить на старте)

Entry nodes

POST /admin/entries/{entryId}/route-node

создать entry-node и привязать к folder

PATCH /admin/entries/{entryId}/route-node

сменить parent folder

сменить slug entry-node

GET /admin/entries/{entryId}/route

вернуть текущий URL

Admin UX (так вы получите “удобство”)

Отдельный раздел “Структура сайта”

дерево folder-узлов

drag-and-drop

показ количества entry в ветке

В форме entry

поле “Расположение” → выбор folder-узла

поле “Slug” → только leaf

live-preview полного URL

При переименовании/перемещении folder-узла

предупреждение:

сколько entry затронет

каким станет новый URL-паттерн

опция “создать редиректы” (если этот механизм включён)

Миграция данных (без обратной совместимости)

Цель миграции — получить дерево минимальной структуры.

Сценарий:

Создать root-folder:

slug может быть пустым/служебным (лучше технический root без slug)

или root с slug не участвует в URL.

Для каждой existing entry:

создать entry-node:

type=entry

parent_id=root

slug = текущий slug entry

entry_id = id entry

Если у вас уже есть “категории/разделы” в доменной модели:

опционально создать folder-узлы по этим сущностям

и распределить entry по ним автоматически.

Старые поля pathSlug:

удалить из модели/форм/валидации

оставить в БД только если нужен аудит (обычно лучше убрать).

Производительность и кеши
Базовые риски

Разрешение пути по дереву на каждый запрос может стать дорогим при большом количестве узлов.

Стратегии оптимизации (по возрастанию сложности)

Кэш резолвинга по path

ключ: route:resolve:{path}

хранить node_id или entry_id

инвалидировать при изменениях внутри поддерева.

Кэш “materialized path”

хранить path_cache в route_nodes

обновлять при:

изменении slug

смене parent

обновление каскадом для children.

Дополнительный индекс routes
Если нагрузка очень большая:

материализовать таблицу вида:

path → entry_id / node_id
Это превращает runtime-резолв в один запрос по уникальному индексу.

На старте, как правило, достаточно пунктов 1–2.

Конкурентность и целостность

Все операции изменения дерева выполняются:

в транзакции

При изменении folder-узла:

обновлять пути/кэши поддерева атомарно

при больших деревьях возможно:

обрабатывать поддерево батчами, но всё равно с консистентной стратегией.

Уникальность (parent_id, slug) должна ловить гонки.

Политики публикации

Варианты:

Простой режим

is_published на folder и entry-node

если folder скрыт → все descendants считаются недоступными публично.

Явный режим

скрытие родителя не меняет детей

но публичный резолвер проверяет “все родители published”.

Рекомендация:

второй вариант предсказуемее: “ветка доступна только если все родители опубликованы”.

SEO и редиректы

Даже если обратная совместимость не нужна, редиректы при изменениях в новой модели всё равно полезны:

переименование раздела

перенос раздела

изменение leaf slug

Политика:

при каждом изменении пути:

автоматически сохранять old → new

отдавать 301

Если вы хотите полностью “жёсткий” подход:

отключите автосохранение редиректов или храните их только для опубликованных узлов.

Безопасность

Контент не должен перехватывать:

системные web пути

API

admin

plugin namespaces

Это обеспечивается:

порядком загрузки роутов

reserved regex на контентном маршруте

RejectReservedIfMatched для первого сегмента

валидацией slug на уровне админских операций.

CSRF

Контентный маршрут остаётся в web группе — это нормально.

Fallback по-прежнему вне web.

Тестирование
Unit

RoutePathBuilder

корректная сборка path

корректная работа при глубине > 3

корректные кейсы root

RouteResolver

успешные резолвы

404 кейсы

проверка публикации родителей

проверка поведения с одинаковыми slug в разных ветках

PathReservationService интеграции

запрет reserved на первом уровне.

Feature/Integration

Роутинг:

запрос на /api/... не должен попадать в content handler

запрос на plugin prefix не должен идти в content handler

запрос на /admin/... не должен идти в content handler

Контент:

/a/b/entry возвращает нужную entry

/a/b если поддерживаете folder page — возвращает страницу раздела

Изменения дерева:

переименование folder:

обновляет путь всех descendants

создаёт редиректы (если включено)

перенос folder:

аналогично

Коллизии:

нельзя создать два дочерних узла с одинаковым slug

нельзя создать root-level folder с reserved slug

Canonical:

uppercase → redirect

trailing slash → redirect к норме

План внедрения по этапам (реально исполнимый)
Этап 0. Подготовка

Зафиксировать список reserved первых сегментов.

Уточнить модель entry: где хранится её текущий slug и как он будет перенесён в entry-node.

Этап 1. База данных

Миграции route_nodes, route_redirects.

Индексы/уникальности/FK.

Этап 2. Модели и сервисы

RouteNode model.

RoutePathBuilder.

RouteTreeService.

RouteResolver.

RouteRedirectService (если включён механизм).

Этап 3. Валидация и политика reserved

Валидатор slug:

формат сегмента

lowercase

singular rules

запрет reserved на первом уровне.

Этап 4. Middleware

Обновить RejectReservedIfMatched:

извлечение первого сегмента из {path}

проверка через сервис резерваций.

Этап 5. Canonical

Убедиться, что canonical нормализует multi-level url.

Этап 6. Публичный контентный роут

В web_content.php:

удалить /{slug}

добавить /{path} (multi-level)

regex + middleware reserved.

Этап 7. Admin API

CRUD дерева.

Операции перемещения.

Привязка entry к nodes.

Этап 8. Админский интерфейс

Дерево разделов с drag-and-drop.

В форме entry:

selector folder

leaf slug

preview полного URL.

Этап 9. Миграция данных

Создать root.

Создать entry-nodes для всех existing entries.

(Опционально) создание folder-узлов из существующих категорий.

Этап 10. Тесты

Unit + integration набор из секции выше.

Этап 11. Производительность

Добавить кэш резолвинга по path.

При необходимости — материализовать path_cache.
