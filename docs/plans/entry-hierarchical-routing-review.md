# Анализ плана переработки системы роутинга Entry

## Обзор

Проверен документ `entry-hierarchical-routing.md` на соответствие текущей реализации системы. Обнаружены несоответствия и уточнения.

---

## Критические несоответствия

### 1. ReservedRouteRegistry — отсутствует метод для иерархических путей

**Проблема:**

-   В плане (Задача 5, Задача 6, Задача 11) упоминается использование `ReservedRouteRegistry` для проверки иерархических путей на всех уровнях
-   В текущей реализации `ReservedRouteRegistry` имеет только:
    -   `isReservedPath()` — проверка точного совпадения
    -   `isReservedPrefix()` — проверка префикса (только для начала пути)
    -   `isReservedSlug()` — проверка первого сегмента

**Не хватает:**

-   Метода для проверки иерархических путей на всех уровнях (если зарезервирован `/torty`, запретить `/torty`, `/torty/mame`, `/torty/mame/na-ubiley`)

**Решение:**

-   Добавить в `ReservedRouteRegistry` метод `isReservedPathHierarchical(string $path): bool`, который проверяет:
    -   Точное совпадение
    -   Если путь является подпутём зарезервированного пути
    -   Если зарезервированный путь является подпутём указанного пути

---

### 2. EntryObserver — не использует ReservedRouteRegistry

**Проблема:**

-   В плане (Задача 6) указано: "Использовать `ReservedRouteRegistry` с новой логикой проверки иерархических путей на всех уровнях"
-   В текущей реализации `EntryObserver::ensureSlug()` напрямую запрашивает `ReservedRoute` из БД, минуя `ReservedRouteRegistry`

**Текущий код:**

```php
$prefixes = ReservedRoute::where('kind', 'prefix')->pluck('path')...
$paths = ReservedRoute::where('kind', 'path')->pluck('path')...
```

**Решение:**

-   Переписать `EntryObserver::ensurePath()` для использования `ReservedRouteRegistry::isReservedPathHierarchical()`

---

### 3. ReservedSlug — не проверяет иерархические пути на всех уровнях

**Проблема:**

-   В плане (Задача 5) указано: "Проверять на всех уровнях пути (не только первый сегмент)"
-   В текущей реализации `ReservedSlug::validate()` проверяет только:
    -   Точное совпадение для `kind='path'`
    -   Начало пути для `kind='prefix'`
    -   Но не проверяет, является ли путь подпутём зарезервированного пути

**Пример:**

-   Если зарезервирован `/torty`, то путь `/torty/mame` должен быть запрещён, но текущая логика этого не проверяет

**Решение:**

-   Обновить `ReservedSlug` (будущий `ReservedPath`) для использования `ReservedRouteRegistry::isReservedPathHierarchical()`

---

### 4. PathReservationService vs ReservedRouteRegistry — путаница в использовании

**Проблема:**

-   В системе есть два сервиса:
    -   `PathReservationService` — для резервации путей (используется в middleware)
    -   `ReservedRouteRegistry` — для проверки зарезервированных путей (объединяет конфиг и БД)
-   В плане не указано, какой сервис использовать где

**Текущее использование:**

-   `RejectReservedIfMatched` использует `PathReservationService::isReserved()`
-   `EntryObserver` напрямую использует `ReservedRoute`
-   `ReservedSlug` напрямую использует `ReservedRoute`

**Рекомендация:**

-   Унифицировать использование: везде использовать `ReservedRouteRegistry` для проверки зарезервированных путей
-   `PathReservationService` оставить только для резервации/освобождения путей

---

## Уточнения и дополнения

### 5. SQL-логика в триггерах — неполная проверка иерархии

**Проблема:**

-   В плане (Задача 1, строки 46-57) приведена SQL-логика для проверки иерархических путей
-   Логика проверяет:
    -   Точное совпадение: `LOWER(NEW.path) = LOWER(rr.path)`
    -   Если путь начинается с зарезервированного: `LOWER(NEW.path) LIKE CONCAT(LOWER(rr.path), '/%')`
    -   Если зарезервированный начинается с пути: `LOWER(rr.path) LIKE CONCAT(LOWER(NEW.path), '/%')`
-   Но для `kind='prefix'` проверка неполная — не проверяется случай, когда зарезервированный префикс является подпутём указанного пути

**Рекомендация:**

-   Обновить SQL-логику в триггерах для полной проверки иерархии

---

### 6. Regex паттерн в валидации — уже поддерживает слеши

**Хорошо:**

-   В `StoreEntryRequest` и `UpdateEntryRequest` regex уже поддерживает слеши:
    ```php
    'regex:/^[a-z0-9]+(?:-[a-z0-9]+)*(?:\/[a-z0-9]+(?:-[a-z0-9]+)*)*$/'
    ```
-   Это соответствует формату из плана (строка 19)

**Но:**

-   Сообщение об ошибке не упоминает слеши (строка 137 в `StoreEntryRequest`):
    ```php
    'slug.regex' => 'The slug format is invalid. Only lowercase letters, numbers, and hyphens are allowed.',
    ```
-   Нужно обновить сообщение, добавив упоминание слешей

---

### 7. Entry::url() — логика не соответствует плану

**Проблема:**

-   В плане (Задача 8) указано: "Упростить метод: удалить проверку типа `page`, всегда возвращать `/{path}`"
-   В текущей реализации метод возвращает:
    -   Для `page`: `/{slug}`
    -   Для остальных: `/{type}/{slug}`

**Текущий код:**

```php
return $type === 'page' ? "/{$slug}" : sprintf('/%s/%s', $type, $slug);
```

**Решение:**

-   После переименования `slug` → `path` упростить до: `return "/{$this->path}";`

---

### 8. EntryController::generateUniqueSlug() — проверка уникальности в рамках post_type

**Проблема:**

-   В плане (Задача 7) указано: "Убрать зависимость от `post_type_id`, проверять глобально по полю `path`"
-   В текущей реализации `generateUniqueSlug()` проверяет уникальность в рамках `post_type_id`:
    ```php
    return Entry::query()
        ->withTrashed()
        ->where('post_type_id', $postType->id)
        ->where('slug', $slug)
        ->exists();
    ```

**Решение:**

-   После переименования `slug` → `path` убрать фильтр по `post_type_id`, проверять глобально

---

### 9. EntryObserver::ensureSlug() — проверка уникальности в рамках post_type

**Проблема:**

-   В плане (Задача 6) указано: "Убрать зависимость от `post_type_id`, проверять глобально по полю `path`"
-   В текущей реализации проверка уникальности выполняется в рамках `post_type_id`:
    ```php
    $exists = Entry::query()
        ->where('slug', $slug)
        ->where('post_type_id', $postTypeId)
        ->exists();
    ```

**Решение:**

-   После переименования `slug` → `path` убрать фильтр по `post_type_id`, проверять глобально

---

### 10. UniqueEntrySlug — проверка уникальности в рамках post_type

**Проблема:**

-   В плане (Задача 5) указано: "Убрать зависимость от `post_type_id`, проверять глобально по полю `path`"
-   В текущей реализации `UniqueEntrySlug` проверяет уникальность в рамках `post_type_id`:
    ```php
    $query = Entry::query()
        ->withTrashed()
        ->where('post_type_id', $postType->id)
        ->where('slug', $value);
    ```

**Решение:**

-   После переименования в `UniqueEntryPath` убрать параметр `$postTypeSlug` из конструктора и проверять глобально

---

## Мелкие несоответствия

### 11. Сообщения об ошибках валидации

**Проблема:**

-   В `StoreEntryRequest` и `UpdateEntryRequest` сообщения об ошибках не упоминают слеши
-   Нужно обновить после переименования `slug` → `path`

---

### 12. PHPDoc комментарии

**Проблема:**

-   Во многих местах PHPDoc упоминает `slug` вместо `path`
-   Нужно обновить после переименования

---

## Рекомендации по доработке плана

1. **Добавить в Задачу 2 (ReservedPattern):**

    - Уточнить, что метод `pathRegex()` должен генерировать негативный lookahead для всех уровней пути, а не только первого сегмента

2. **Добавить в Задачу 5 (ReservedPath):**

    - Явно указать использование `ReservedRouteRegistry::isReservedPathHierarchical()` (который нужно создать)

3. **Добавить в Задачу 6 (EntryObserver):**

    - Явно указать использование `ReservedRouteRegistry::isReservedPathHierarchical()` вместо прямого запроса к БД

4. **Добавить в Задачу 11 (Middleware):**

    - Уточнить, что `RejectReservedIfMatched` должен использовать `ReservedRouteRegistry::isReservedPathHierarchical()` вместо `PathReservationService::isReserved()`

5. **Добавить новую задачу:**
    - Создать метод `ReservedRouteRegistry::isReservedPathHierarchical(string $path): bool` для проверки иерархических путей на всех уровнях

---

## Итоговая оценка

**План в целом корректен**, но требует уточнений:

✅ **Правильно:**

-   Общая структура задач
-   Порядок выполнения
-   Переименование `slug` → `path`
-   Изменение уникальности на глобальную
-   Поддержка иерархических путей в regex

❌ **Требует доработки:**

-   Логика проверки иерархических путей на всех уровнях (не только первый сегмент)
-   Унификация использования `ReservedRouteRegistry` вместо прямых запросов к БД
-   Создание метода `isReservedPathHierarchical()` в `ReservedRouteRegistry`
-   Обновление SQL-логики в триггерах для полной проверки иерархии

---

**Дата проверки:** 2025-12-02
**Проверено:** Система роутинга Entry, миграции, валидация, observer, контроллеры

