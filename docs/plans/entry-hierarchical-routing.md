# План переработки системы роутинга Entry для поддержки иерархических URL

## Цель

Переработать систему роутинга entry для поддержки полных иерархических URL вместо плоских slug. Пример: `/torty/mame/na-ubiley` вместо `/na-ubiley`.

## Текущее состояние

-   Entry доступны только по плоскому slug: `/{slug}`
-   Slug ограничен форматом `[a-z0-9-]+` (без слешей)
-   Максимальная длина slug: 255 символов
-   Уникальность slug в рамках `post_type_id`
-   Роутинг через `ReservedPattern::slugRegex()` с негативным lookahead

## Целевое состояние

-   Entry доступны по полному пути: `/{path}`, где path может содержать слеши
-   Path может быть иерархическим: `/torty/mame/na-ubiley`
-   Формат path: `[a-z0-9]+(?:-[a-z0-9]+)*(?:\/[a-z0-9]+(?:-[a-z0-9]+)*)*`
-   Максимальная длина path: 500 символов (для поддержки глубоких иерархий)
-   Уникальность path глобально (не в рамках post_type)
-   Проверка конфликтов с зарезервированными путями на всех уровнях
-   **Поле в БД переименовано с `slug` на `path`** для единообразия

---

## Задачи

### Задача 1: Изменить миграцию entries для поддержки иерархических path

**Файл:** `database/migrations/2025_11_06_000020_create_entries_table.php`

**Изменения:**

1. **Переименовать поле `slug` в `path`** для единообразия с концепцией приложения
2. Изменить тип поля с `string('slug')` на `string('path', 500)` для поддержки длинных путей
3. Удалить уникальный индекс `entries_unique_active_slug` (по `post_type_id`, `slug`, `is_active`)
4. Создать новый уникальный индекс по `path` и `is_active` (глобальная уникальность)
5. Обновить триггеры MySQL:
    - Переименовать все упоминания `slug` на `path` в триггерах
    - **Полностью удалить проверку уникальности для типа `page`** (теперь глобальная уникальность через индекс)
    - Обновить проверку зарезервированных путей для поддержки многоуровневых path:
        - Для `kind='path'`: проверять точное совпадение, а также если путь является подпутём зарезервированного пути или зарезервированный путь является подпутём указанного пути
        - Для `kind='prefix'`: проверять, начинается ли путь с зарезервированного префикса
        - Пример SQL: если зарезервирован `/torty`, запретить `/torty`, `/torty/mame`, `/torty/mame/na-ubiley` и т.д.
        - Пример SQL логики:
            ```sql
            WHERE (rr.kind = 'path' AND (
                LOWER(NEW.path) = LOWER(rr.path)
                OR LOWER(NEW.path) LIKE CONCAT(LOWER(rr.path), '/%')
                OR LOWER(rr.path) LIKE CONCAT(LOWER(NEW.path), '/%')
            ))
            OR (rr.kind = 'prefix' AND (
                LOWER(NEW.path) = LOWER(rr.path)
                OR LOWER(NEW.path) LIKE CONCAT(LOWER(rr.path), '/%')
            ))
            ```
6. Для SQLite: обновить уникальный индекс на `['path']` (без `post_type_id` и без `is_active`, так как SQLite не поддерживает generated columns)

**Критерии готовности:**

-   Миграция проходит без ошибок
-   Уникальный индекс работает глобально
-   Триггеры корректно проверяют зарезервированные пути на всех уровнях

---

### Задача 2: Обновить ReservedPattern для поддержки иерархических путей

**Файл:** `app/Domain/Routing/ReservedPattern.php`

**Изменения:**

1. Переименовать метод `slugRegex()` в `pathRegex()` для ясности
2. Изменить логику генерации regex:
    - Обновить базовый паттерн для поддержки слешей: `[a-z0-9]+(?:-[a-z0-9]+)*(?:\/[a-z0-9]+(?:-[a-z0-9]+)*)*`
    - Вместо исключения только первого сегмента, исключать зарезервированные пути на всех уровнях
    - Поддержать проверку префиксов на всех уровнях (если зарезервирован `/torty`, запретить `/torty/*`)
    - Генерировать негативный lookahead для всех зарезервированных путей (не только первый сегмент)
3. Обновить PHPDoc с описанием новой логики

**Примечание:** Не добавлять метод проверки `isReservedPath()` в этот класс. Для проверки зарезервированности путей использовать `ReservedRouteRegistry` (см. задачу 6).

**Критерии готовности:**

-   Regex корректно исключает зарезервированные пути на всех уровнях
-   Тесты проходят

---

### Задача 3: Обновить роутинг для поддержки иерархических путей

**Файл:** `routes/web_content.php`

**Изменения:**

1. Изменить параметр роута с `slug` на `path`
2. Обновить regex паттерн: использовать `ReservedPattern::pathRegex()` вместо `slugRegex()` для поддержки иерархических путей
3. **НЕ использовать catch-all `.*`** — использовать строгий regex из `ReservedPattern::pathRegex()` для предотвращения конфликтов с другими роутами
4. **Важно:** Убедиться, что роут регистрируется ПОСЛЕ всех других специфичных роутов (API, admin и т.д.)
5. Обновить middleware `RejectReservedIfMatched` для работы с `path` вместо `slug`
6. Обновить комментарии в файле с указанием порядка регистрации роутов

**Файл:** `app/Http/Controllers/PageController.php`

**Изменения:**

1. Изменить параметр метода `show()` с `string $slug` на `string $path`
2. Обновить поиск entry: `Entry::published()->where('path', $path)->first()`
3. Обновить PHPDoc с описанием новой логики

**Файл:** `app/Http/Requests/PageShowRequest.php`

**Изменения:**

1. Обновить PHPDoc: упомянуть `path` вместо `slug`

**Критерии готовности:**

-   Роут корректно обрабатывает иерархические пути
-   PageController находит entry по полному path
-   Тесты проходят

---

### Задача 4: Обновить валидацию path в Request классах

**Файл:** `app/Http/Requests/Admin/StoreEntryRequest.php`

**Изменения:**

1. **Переименовать поле `slug` в `path`** в правилах валидации
2. Обновить regex для path: уже поддерживает слеши, но обновить сообщение об ошибке
3. Увеличить `max:255` до `max:500` для поддержки длинных путей
4. Обновить сообщение об ошибке: "The path format is invalid. Only lowercase letters, numbers, hyphens, and slashes are allowed." (убедиться, что упомянуты слеши)
5. Обновить PHPDoc: упомянуть поддержку иерархических путей и переименование поля

**Файл:** `app/Http/Requests/Admin/UpdateEntryRequest.php`

**Изменения:**

1. Аналогично StoreEntryRequest: обновить max, сообщения, PHPDoc

**Критерии готовности:**

-   Валидация корректно проверяет иерархические пути
-   Сообщения об ошибках актуальны
-   Тесты проходят

---

### Задача 5: Переименовать и обновить правила валидации

**Файл:** `app/Rules/UniqueEntrySlug.php`

**Изменения:**

1. **Переименовать класс в `UniqueEntryPath`** и файл в `UniqueEntryPath.php`
2. Изменить проверку уникальности: убрать зависимость от `post_type_id`, проверять глобально по полю `path`
3. Удалить параметр `$postTypeSlug` из конструктора (больше не нужен)
4. Обновить все упоминания `slug` на `path` в коде
5. Обновить PHPDoc с описанием глобальной уникальности по полю `path`

**Файл:** `app/Rules/ReservedSlug.php`

**Изменения:**

1. **Переименовать класс в `ReservedPath`** и файл в `ReservedPath.php`
2. Обновить проверку конфликтов: проверять на всех уровнях пути
3. Логика проверки:
    - Если зарезервирован путь `/torty`, запретить `/torty`, `/torty/mame`, `/torty/mame/na-ubiley` и т.д.
    - Если зарезервирован префикс `/torty`, запретить все пути, начинающиеся с `/torty/`
    - Проверять все уровни пути (не только первый сегмент)
4. Использовать `ReservedRouteRegistry` для проверки (создать или обновить метод для иерархических путей)
5. Обновить все упоминания `slug` на `path` в коде и PHPDoc

**Критерии готовности:**

-   Правила валидации корректно проверяют глобальную уникальность
-   Проверка зарезервированных путей работает на всех уровнях
-   Тесты проходят

---

### Задача 6: Обновить EntryObserver для генерации иерархических path

**Файл:** `app/Observers/EntryObserver.php`

**Изменения:**

1. Обновить метод `ensureSlug()`:
    - **Переименовать в `ensurePath()`** для ясности
    - Обновить логику генерации: если пользователь указал path со слешами, нормализовать его
    - При автогенерации из title: генерировать плоский path (как сейчас), но разрешить ручное указание иерархического path
    - Обновить проверку уникальности: убрать зависимость от `post_type_id`, проверять глобально по полю `path`
    - Обновить проверку зарезервированных путей: использовать `ReservedRouteRegistry` с новой логикой проверки иерархических путей на всех уровнях
    - Обновить все обращения к `$entry->slug` на `$entry->path`
2. Обновить PHPDoc с описанием новой логики и переименования поля

**Критерии готовности:**

-   Observer корректно генерирует и нормализует иерархические path
-   Проверка уникальности работает глобально
-   Тесты проходят

---

### Задача 7: Обновить EntryController для работы с path

**Файл:** `app/Http/Controllers/Admin/V1/EntryController.php`

**Изменения:**

1. Обновить метод `generateUniqueSlug()`:
    - **Переименовать в `generateUniquePath()`**
    - Обновить логику: убрать зависимость от `post_type_id`, проверять глобально по полю `path`
    - Обновить callback для `ensureUnique()`: проверять глобальную уникальность по полю `path`
2. Обновить метод `store()`: использовать `generateUniquePath()` вместо `generateUniqueSlug()`
3. Обновить поиск в методе `index()`: поиск по полю `path`
4. Обновить все обращения к `slug` на `path` в контроллере
5. Обновить PHPDoc во всех методах: упомянуть поддержку иерархических path и переименование поля

**Критерии готовности:**

-   Контроллер корректно генерирует уникальные path
-   Поиск работает корректно
-   Тесты проходят

---

### Задача 8: Обновить модель Entry

**Файл:** `app/Models/Entry.php`

**Изменения:**

1. **Обновить свойство модели**: переименовать `slug` в `path` в PHPDoc (поле в БД уже переименовано)
2. Обновить метод `url()`:
    - Упростить логику: всегда возвращать `/{path}`, где `path` содержит полный путь
    - Удалить проверку типа `page` (больше не нужна)
    - Обновить все обращения к `$this->slug` на `$this->path`
    - Упростить метод: удалить проверку типа `page`, всегда возвращать `/{$this->path}`
3. Обновить PHPDoc свойства `path`: "Полный путь записи (может содержать слеши для иерархических URL)"
4. Обновить PHPDoc метода `url()`: описать новую логику (всегда возвращает `/{path}` независимо от типа записи)

**Критерии готовности:**

-   Метод `url()` корректно возвращает полный path
-   PHPDoc актуален
-   Тесты проходят

---

### Задача 9: Обновить все тесты

**Файлы:**

-   `tests/Feature/Api/Entries/CreateEntryTest.php`
-   `tests/Feature/Api/Entries/UpdateEntryTest.php`
-   `tests/Feature/Api/Entries/ShowEntryTest.php`
-   `tests/Feature/Api/Entries/DeleteRestoreEntryTest.php`
-   `tests/Feature/Models/EntryTest.php`
-   `tests/Unit/Models/EntryTest.php`
-   `tests/Unit/Rules/UniqueEntryPathTest.php` (переименован из `UniqueEntrySlugTest.php`)
-   `tests/Feature/EntryIndexingTest.php`
-   Все остальные тесты, использующие entry/slug

**Изменения:**

1. **Обновить все обращения к `slug` на `path`** в тестах (поле переименовано в БД)
2. Обновить тесты на создание entry: добавить тесты с иерархическими path
3. Обновить тесты на валидацию: проверить поддержку слешей в path
4. Обновить тесты на уникальность: проверить глобальную уникальность (не в рамках post_type)
5. Обновить тесты на зарезервированные пути: проверить конфликты на всех уровнях
6. Обновить тесты на роутинг: проверить доступность entry по иерархическим path
7. Переименовать тесты: `UniqueEntrySlugTest.php` → `UniqueEntryPathTest.php`

**Критерии готовности:**

-   Все тесты проходят
-   Покрыты новые сценарии (иерархические path, глобальная уникальность)
-   Удалены устаревшие тесты (если есть)

---

### Задача 10: Обновить сидеры и фабрики

**Файл:** `database/factories/EntryFactory.php`

**Изменения:**

1. **Обновить генерацию**: переименовать `slug` в `path` в фабрике
2. Использовать плоские path по умолчанию (для обратной совместимости в тестах)
3. Добавить метод `withPath(string $path)`: для явного указания иерархического path

**Файлы сидеров:**

-   `database/seeders/EntriesSeeder.php`
-   `database/seeders/BlueprintEntriesSeeder.php`
-   Все остальные сидеры, создающие entries

**Изменения:**

1. Обновить примеры entries: добавить примеры с иерархическими path
2. Пример: создать entry с path `/torty/mame/na-ubiley`
3. Обновить комментарии в сидерах

**Критерии готовности:**

-   Сидеры создают entries с иерархическими path
-   Фабрики поддерживают явное указание path
-   `php artisan migrate:refresh --seed` проходит без ошибок

---

### Задача 11: Обновить middleware RejectReservedIfMatched

**Файл:** `app/Http/Middleware/RejectReservedIfMatched.php`

**Изменения:**

1. Изменить параметр с `slug` на `path`
2. Обновить проверку: использовать `ReservedRouteRegistry::isReservedPath()` или создать новый метод `isReservedPathHierarchical()` для проверки иерархических путей на всех уровнях (объединяет проверки из конфига и БД)
3. Проверка должна работать на всех уровнях: если зарезервирован `/torty`, запретить `/torty`, `/torty/mame`, `/torty/mame/na-ubiley` и т.д.
4. Обновить PHPDoc

**Критерии готовности:**

-   Middleware корректно проверяет зарезервированные пути на всех уровнях
-   Тесты проходят

---

### Задача 12: Глобальное переименование slug → path в коде

**Файлы для обновления:**

1. **Модель Entry** (`app/Models/Entry.php`):

    - Обновить все обращения к `$this->slug` на `$this->path`
    - Обновить PHPDoc свойства

2. **Все контроллеры, использующие Entry**:

    - Заменить `$entry->slug` на `$entry->path`
    - Заменить `'slug'` в массивах на `'path'`

3. **Все сервисы и классы, работающие с Entry**:

    - Обновить обращения к полю `slug` на `path`

4. **Все тесты**:

    - Заменить `'slug'` на `'path'` в данных тестов
    - Обновить assertions

5. **Все сидеры и фабрики**:

    - Заменить `'slug'` на `'path'` в массивах данных

6. **ReservedRouteRegistry**:
    - Обновить использование `ReservedRouteRegistry::isReservedSlug()` на новый метод для работы с иерархическими path (если требуется)
    - Обновить методы проверки для поддержки проверки на всех уровнях пути

**Критерии готовности:**

-   Все обращения к полю `slug` заменены на `path`
-   Код компилируется без ошибок
-   Тесты проходят

---

### Задача 13: Удалить устаревший код и обновить документацию

**Удалить:**

1. Устаревшие методы/классы (если есть)
2. Устаревшие комментарии, ссылающиеся на плоские slug

**Обновить:**

1. PHPDoc во всех затронутых файлах
2. Комментарии в коде
3. README или другую документацию (если есть)

**Критерии готовности:**

-   Устаревший код удален
-   Документация актуальна
-   Комментарии в коде соответствуют новой логике

---

## Порядок выполнения

1. **Задача 1** (миграция) - основа для всех остальных изменений
2. **Задача 2** (ReservedPattern) - требуется для роутинга
3. **Задача 3** (роутинг) - основная функциональность
4. **Задача 4-7** (валидация, правила, observer, controller) - можно параллельно
5. **Задача 8** (модель) - после изменения логики
6. **Задача 9** (тесты) - после всех изменений
7. **Задача 10** (сидеры) - после изменения модели
8. **Задача 11** (middleware) - после изменения роутинга
9. **Задача 12** (глобальное переименование) - после всех изменений логики
10. **Задача 13** (очистка) - финальная задача

## Команды для выполнения после завершения

```bash
# Очистить кэш роутов
php artisan route:clear
php artisan route:cache

# Обновить БД
php artisan migrate:refresh --seed

# Запустить тесты
php artisan test

# Обновить документацию
php artisan docs:generate
composer scribe:gen
```

## Важные замечания

1. **Обратная совместимость не требуется** - можно ломать существующий API
2. **Изменить целевую миграцию** - не создавать новые миграции, изменить существующую
3. **Удалить устаревший код** - не оставлять legacy код
4. **Обновить все тесты** - покрыть новые сценарии
5. **Обновить сидеры** - добавить примеры с иерархическими path

## Миграция данных (если требуется)

Если в продакшене есть существующие записи, перед изменением структуры БД нужно:

1. Проверить наличие конфликтов slug при переходе на глобальную уникальность
2. Если есть конфликты — создать скрипт миграции для разрешения конфликтов (например, добавить суффикс)
3. Выполнить миграцию данных перед изменением структуры БД

## Риски и митигация

1. **Производительность**: Глобальная уникальность может быть медленнее. Митигация: добавить индекс на `path`.
2. **Конфликты путей**: Разные post_type могут конфликтовать. Митигация: глобальная уникальность предотвращает конфликты.
3. **Зарезервированные пути**: Нужно проверять на всех уровнях. Митигация: использовать `ReservedRouteRegistry` с проверкой на всех уровнях пути.
4. **Порядок роутов**: Catch-all роут может перехватить другие маршруты. Митигация: использовать строгий regex и регистрировать роут последним.
5. **Миграция данных**: При переходе с локальной на глобальную уникальность могут возникнуть конфликты. Митигация: перед миграцией проверить все существующие slug на конфликты.

## Важные предупреждения

1. **Перед началом работы:** Проверить, есть ли в продакшене существующие записи, которые нужно мигрировать. Если да — создать план миграции данных.
2. **Порядок роутов:** Роут `/{path}` должен быть зарегистрирован последним в `routes/web_content.php`, после всех других специфичных роутов.
3. **Тестирование:** Все тесты должны быть обновлены и проходить перед деплоем в продакшен.
4. **Индексы БД:** Убедиться, что уникальный индекс на `path` создан корректно для глобальной уникальности.
