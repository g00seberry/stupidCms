# План реализации DB-driven системы роутинга для визуального конструктора (Laravel)

Ниже приведён последовательный план работ для реализации системы управления роутингом, управляемой из БД, с поддержкой назначения `entry`, групп/префиксов, middleware и основных возможностей роутинга Laravel.  
Каждый блок задач завершается **блоком тестов**, которые должны быть написаны и выполнены сразу после реализации соответствующего блока.

---

## 0. Цели и рамки

### Цели
1. Дать фронтенду API для визуального конструктора дерева маршрутов.
2. Хранить структуру маршрутов и настройки в БД.
3. Компилировать дерево в реальные Laravel-роуты при boot приложения.
4. Поддержать привязку `entry` к конкретному маршруту.
5. Поддержать middleware, методы, where-условия, defaults, домены, группы.
6. Обеспечить безопасность (white-list действий и middleware).
7. Обеспечить предсказуемый порядок регистрации и совместимость с существующими слоями (core/public/admin/content/fallback).

### Нефункциональные требования
- Производительность: кэш дерева и минимизация N+1.
- Наблюдаемость: логирование изменений и ошибок компиляции.
- Надёжность: тестовое покрытие ключевых контрактов.

### Ограничения
- Нельзя хранить в БД closures.
- Action должен быть декларативным: `Controller@method`, invokable, специальные action_type (`entry`, `redirect`, `view`).
- Middleware и action должны быть доступны только из разрешённого списка.

---

## 1. Блок: Проектирование модели данных

### Задачи
1.1. Описать сущность **RouteNode** как универсальный узел дерева.  
Поддерживаемые `kind`:
- `group` — групповой узел для атрибутов `prefix/domain/middleware/where`.
- `route` — конечный маршрут.
- `redirect` — редирект-узел (может быть отдельным kind или action_type).
- `resource` — ограниченный декларативный ресурсный узел (опционально, можно включить позже).

1.2. Утвердить поля (минимальный обязательный набор):
- `parent_id`, `sort_order`, `enabled`
- `kind`
- `name`, `domain`
- `prefix`, `namespace` (для group)
- `methods`, `uri` (для route)
- `action_type`, `action`, `view`
- `entry_id`
- `middleware`, `where`, `defaults`, `options`

1.3. Определить стратегию версионирования/миграций:
- добавить индекс по `(parent_id, sort_order)` 
- рассмотреть уникальность `name` на уровне приложения (не обязательно DB-constraint на старте).

1.4. Подготовить ER-диаграмму/описание связей:
- `RouteNode` self-relation (parent/children)
- `RouteNode` belongsTo `Entry`

### Результаты
- Финальная спецификация таблицы `route_nodes`.
- Согласованный список допустимых `kind` и `action_type`.

---

### Тесты после блока 1
**Документальные/архитектурные тесты (командные):**
- Проверить, что спецификация полей покрывает все нужные кейсы конструктора:  
  group + nested group, route with entry, route with controller, redirect.
- Зафиксировать список `kind/action_type` как enums/константы в коде (проверяется далее на уровне unit).

---

## 2. Блок: Миграции и модели Eloquent

### Задачи
2.1. Создать миграцию `route_nodes`.  
2.2. Добавить foreign key на `entries` (если таблица `entries` уже существует).  
2.3. Создать модель `RouteNode`:
- `$fillable`
- `$casts` для JSON-полей
- `parent()`, `children()`, `entry()`.

2.4. Добавить фабрику `RouteNodeFactory` для тестов.  
2.5. Добавить сидер (опционально) с примером дерева для локальной разработки.

### Результаты
- Рабочая модель и таблица.
- Базовая возможность создавать/читать дерево вручную.

---

### Тесты после блока 2
**Unit/Feature:**
1. `RouteNode` корректно создаётся и сохраняет JSON-поля:
   - `methods`, `middleware`, `where`, `defaults`, `options`.
2. Self-relation работает:
   - `parent_id` задаёт родителя.
   - `children()` возвращает отсортированных потомков по `sort_order`.
3. Связь `entry()` работает и корректно обрабатывает `nullOnDelete`.

---

## 3. Блок: Репозиторий дерева и оптимизация запросов

### Задачи
3.1. Создать `RouteNodeRepository` с методом:
- `getTree()` — возвращает корневые узлы с eager loading детей на нужную глубину.

3.2. Избежать N+1:
- использовать рекурсивную загрузку через кастомный scope/метод,
- либо загрузка всех узлов одним запросом + сборка дерева в памяти.

3.3. Ввести контракт сортировки:
- сначала `sort_order`, затем `id` как стабильный tie-breaker.

3.4. Добавить фильтр `enabled=true` на этапе выборки (или на этапе регистрации).

### Результаты
- Репозиторий, выдающий детерминированное дерево.

---

### Тесты после блока 3
**Unit:**
1. `getTree()` возвращает структуру корректной вложенности.
2. Сортировка детей идёт по `sort_order`.
3. При одинаковом `sort_order` порядок стабилен.

**Performance smoke (локально):**
- В тесте с 200–500 узлами убедиться, что число запросов не растёт линейно с глубиной.

---

## 4. Блок: Guard (безопасность action и middleware)

### Задачи
4.1. Создать `DynamicRouteGuard`:
- белый список middleware-алиасов.
- разрешение параметризованных алиасов:
  - `can:*`
  - `throttle:*`
  - (при необходимости) `signed`, `verified` и т.д. по политике проекта.

4.2. Белый список контроллеров/действий:
- список разрешённых контроллеров для action_type `controller/invokable`.
- запрет произвольных строк.

4.3. Правило поведения при нарушении:
- действие заменяется на безопасное `fn() => abort(404)`  
  или узел пропускается при регистрации (предпочтительно фиксировать в логах).

4.4. Добавить конфигурационный файл:
- `config/dynamic-routes.php`  
  с массивами `allowed_middleware`, `allowed_controllers`, `reserved_prefixes`.

### Результаты
- Централизованная политика безопасности.

---

### Тесты после блока 4
**Unit:**
1. Middleware-фильтрация:
   - разрешённые проходят,
   - неизвестные отбрасываются,
   - `can:xxx` и `throttle:x,y` проходят.
2. Action-фильтрация:
   - разрешённый `Controller@method` проходит,
   - неразрешённый заменяется на safe action.
3. Конфиг корректно подхватывается.

---

## 5. Блок: Регистратор динамических маршрутов

### Задачи
5.1. Создать сервис `DynamicRouteRegistrar`:
- принимает `RouteNodeRepository`, `DynamicRouteGuard`, (позже) `DynamicRouteCache`.

5.2. Реализовать регистрацию:
- `group` узлы -> `Route::group([...], fn() => children)`
- `route` узлы -> `Route::match($methods, $uri, $action)`
- поддержать:
  - `name`
  - `domain`
  - `middleware`
  - `where`
  - `defaults`

5.3. Реализовать `action_type`:
- `controller`
- `invokable`
- `view`
- `redirect`
- `entry` (пока заглушка на контроллер страницы entry).

5.4. Обработка `enabled=false`:
- узел не регистрируется.

5.5. Добавить структурное логирование ошибок регистрации.

### Результаты
- Появляется реальный слой DB-маршрутов.

---

### Тесты после блока 5
**Feature (router integration):**
1. Локальная регистрация тестового дерева:
   - группа с prefix + дочерний GET route  
     -> корректный ответ 200.
2. Проверка `where`:
   - валидный параметр проходит,
   - невалидный даёт 404.
3. Проверка middleware:
   - тестовый middleware срабатывает при наличии в белом списке.
4. Узел `enabled=false` не создаёт маршрут.

---

## 6. Блок: Интеграция с Entry

### Задачи
6.1. Создать `EntryPageController@show`:
- получает `route_node_id` из defaults маршрута.
- загружает `RouteNode` с `entry`.
- отдаёт данные entry (JSON или SSR/response по вашей архитектуре).

6.2. В регистраторе:
- при `action_type=entry` задавать action на `EntryPageController@show`
- добавлять default:
  - `route_node_id = $node->id`

6.3. Решить поведение при отсутствии entry:
- 404.

6.4. Опционально:
- поддержать альтернативный режим поиска entry по slug из URI.

### Результаты
- Конструктор может выбирать entry и назначать его на конкретный URL.

---

### Тесты после блока 6
**Feature:**
1. Роут `action_type=entry` возвращает entry.
2. Если `entry_id` отсутствует -> 404.
3. Если узел отключён -> маршрут не доступен.

---

## 7. Блок: Кэширование дерева и сброс кэша

### Задачи
7.1. Создать `DynamicRouteCache`:
- `rememberTree()` с ключом версии, например `dynamic_routes.tree.v1`.

7.2. Подключить кэш в `DynamicRouteRegistrar`.

7.3. Сбрасывать кэш при изменениях:
- `RouteNodeObserver` на `saved`, `deleted`.

7.4. Добавить Artisan-команды:
- `routes:dynamic-cache` (прогрев)
- `routes:dynamic-clear` (сброс)

### Результаты
- Стабильная производительность.

---

### Тесты после блока 7
**Unit/Feature:**
1. `rememberTree()` не вызывает builder повторно при наличии кэша.
2. Observer сбрасывает кэш на `save/delete`.
3. Команды корректно работают (smoke тест).

---

## 8. Блок: Встраивание в RouteServiceProvider

### Задачи
8.1. Добавить вызов регистратора в правильный слой:
- после core/public/admin/content файлов
- до глобального fallback.

8.2. Убедиться, что динамические маршруты не перехватывают системные префиксы:
- через политику `reserved_prefixes` на уровне валидации админ API.

8.3. Зафиксировать порядок в коде и комментариях.

### Результаты
- Динамические маршруты живут в нужном месте вашей иерархии.

---

### Тесты после блока 8
**Feature:**
1. Маршрут из БД доступен.
2. Существующие системные маршруты имеют приоритет.
3. Fallback не перехватывает корректные dynamic routes.

---

## 9. Блок: Admin API для конструктора

### Задачи
9.1. Создать контроллер:
- `Admin\RouteNodeController`

9.2. Реализовать endpoints:
- `GET /admin/routes/tree`
- `POST /admin/routes`
- `PATCH /admin/routes/{id}`
- `DELETE /admin/routes/{id}`
- `POST /admin/routes/reorder`

9.3. Реализовать `FormRequest`-валидацию:
- `kind` enum
- `action_type` enum
- `methods` допустимые значения
- `middleware` массив строк
- проверка `uri/prefix` на запрещённые префиксы:
  - `api`, `admin`, `sanctum`, и ваши системные (по конфигу).

9.4. Авторизация:
- `jwt.auth` + `can:manage-routes` (или ваш аналог).

9.5. Возврат данных в формате, удобном для дерева на фронте:
- `id, parent_id, sort_order, kind, name, uri/prefix, action_type, entry_id, enabled`.

### Результаты
- Конструктор получает полный CRUD и reorder для дерева.

---

### Тесты после блока 9
**Feature:**
1. Авторизация обязательна.
2. Создание узла:
   - корректные данные -> 201.
   - запрещённый префикс -> 422.
3. Обновление узла:
   - изменение `middleware/methods` валидируется.
4. Delete:
   - удаление родителя корректно обрабатывает детей (согласно политике).
5. Reorder:
   - меняет `parent_id` и `sort_order` атомарно.

---

## 10. Блок: Поведение удаления и целостность дерева

### Задачи
10.1. Определить политику удаления:
- вариант A: каскадное удаление дочерних узлов;
- вариант B: запрет удаления родителя с детьми;
- вариант C: перенос детей на корень.

10.2. Реализовать выбранную политику:
- на уровне сервиса/репозитория.

10.3. Добавить транзакции на операции массового reorder + delete.

### Результаты
- Предсказуемое поведение дерева.

---

### Тесты после блока 10
**Feature/Unit:**
1. Удаление родителя ведёт к ожидаемому результату по политике.
2. Reorder сохраняет дерево консистентным при ошибке (rollback).

---

## 11. Блок: Расширенные возможности (опционально, но последовательно)

### Задачи
11.1. `redirect` как отдельный kind:
- поддержка `status` и `to` в `options`.

11.2. Ограниченный `resource`:
- хранить `resource` и `controller` в `options`.
- поддержать `only/except` (если нужно).

11.3. Локализация:
- возможность хранить `locale` или `site_id` как часть `options`/defaults.

11.4. Мультисайт/мультидомен:
- использование `domain` на group или route узлах.

### Результаты
- Уровень возможностей ближе к “почти всё, что даёт Laravel”, но безопасно и декларативно.

---

### Тесты после блока 11
**Feature:**
1. Redirect:
   - корректный статус и target.
2. Resource:
   - регистрируется только если controller разрешён guard.
3. Domain:
   - роут доступен только на нужном домене (если тестовая среда позволяет).

---

## 12. Блок: Наблюдаемость и DX

### Задачи
12.1. Логирование изменений:
- при создании/обновлении/удалении route nodes.

12.2. Логирование проблем компиляции:
- неразрешённые middleware/action
- конфликт имён

12.3. Добавить команду диагностики:
- `routes:dynamic-lint`  
  выводит предупреждения по дереву.

### Результаты
- Удобство поддержки и уменьшение риска “тихих” проблем.

---

### Тесты после блока 12
**Unit/Feature:**
1. `routes:dynamic-lint` находит:
   - неизвестные middleware
   - запрещённые action
   - конфликтные или пустые uri
2. Логи пишутся при изменениях.

---

## 13. Блок: Регрессионный набор

### Задачи
13.1. Собрать набор сценариев end-to-end:
- core/public/admin routes живут параллельно с dynamic.
- dynamic content не ломает fallback.
- CSRF/guard/авторизация не ломаются.

13.2. Добавить тест на порядок регистрации:
- dynamic регистрируется до fallback.

### Результаты
- Зафиксирован контракт вашей общей роутинг-архитектуры.

---

### Тесты после блока 13
**E2E/Feature:**
1. Проверка приоритета слоёв:
   - системный путь не перехватывается dynamic.
2. Fallback отдаёт 404 только при отсутствии системных и dynamic маршрутов.

---

## 14. Рекомендованный порядок внедрения в прод

1. Включить систему в режиме **read-only**:
   - регистрация из БД включена,
   - admin API доступен только dev/ops.
2. Прогреть кэш.
3. Дать фронту доступ к tree-read.
4. Постепенно открыть CRUD.
5. Включить lint-команду в CI.

---

## 15. Мини-чеклист готовности

- [ ] Миграции и модель `RouteNode` готовы.  
- [ ] Репозиторий дерева без N+1.  
- [ ] Guard с белыми списками.  
- [ ] Регистратор поддерживает group/route/entry/view/redirect.  
- [ ] Кэш + observer + команды.  
- [ ] Интеграция в `RouteServiceProvider` до fallback.  
- [ ] Admin API с валидацией и авторизацией.  
- [ ] Тесты по каждому блоку проходят.  
- [ ] Lint-команда в CI.  

---

## 16. Пример минимального дерева для ручной проверки

1) `group` prefix=`blog` middleware=`["web"]`  
2) child `route` uri=`{slug}` methods=`["GET"]`  
   action_type=`controller` action=`App\Http\Controllers\Blog\PostController@show`  
   where=`{"slug":"[a-z0-9-]+"}`

3) `route` uri=`about` methods=`["GET"]`  
   action_type=`entry` entry_id=`123`

---

## 17. Что сознательно не включаем в MVP

- closures в action
- произвольные классы middleware без whitelist
- сложные route macros
- динамическое “исполнение кода из БД”

---

## 18. Итог

План выше позволяет поэтапно и безопасно построить систему динамического роутинга, полностью пригодную для визуального конструктора во фронтенде, сохраняя принципы Laravel и вашу текущую слоистую архитектуру.

