# Задача 33. Blade шаблоны по приоритету

## Резюме
Вынести стратегию выбора Blade-шаблона для рендера записи (`Entry`) в отдельный сервис. Приоритет выбора:
1) **Override** (на уровне конкретной записи / slug) — если существует.
2) **Шаблон пост-типа** (`postType.template`) — если задан.
3) **Default** — общий шаблон по умолчанию.

**Критерии приёмки:** при наличии override он используется; иначе — шаблон пост-типа; иначе — дефолт.

Связанные: 31 (PageController использует сервис), 32 (HomeController на главной), 20 (модели/связи `Entry->postType`), 21 (slugify), 24 (история слугов).

---

## Соглашения о путях шаблонов
Принять консистентные имена view:
- Override: `pages/overrides/{slug}` (например, `pages/overrides/about`).
- По типу поста: `pages/types/{postTypeKey}` (например, `pages/types/page`, `pages/types/news`).
- Дефолт: `pages/show` (совпадает с текущим шаблоном из задачи 31).

> В дальнейшем «override» можно расширить на поле в БД `entries.template_override` — но в этой задаче делаем файловые override-ы по slug.

---

## Контракт сервиса
```php
namespace App\Domain\View;

use App\Models\Entry;

interface TemplateResolver
{
    /** Вернуть имя blade-шаблона для рендера Entry. */
    public function forEntry(Entry $entry): string;
}
```

### Реализация
```php
namespace App\Domain\View;

use App\Models\Entry;
use Illuminate\Support\Facades\View;

final class BladeTemplateResolver implements TemplateResolver
{
    public function __construct(
        private string $default = 'pages.show',
        private string $overridePrefix = 'pages.overrides.',
        private string $typePrefix = 'pages.types.',
    ) {}

    public function forEntry(Entry $entry): string
    {
        // 1) Override по slug
        $override = $this->overridePrefix . $entry->slug; // pages.overrides.about
        if (View::exists($override)) {
            return $override;
        }

        // 2) По типу поста (ключ берём из связи/атрибута postType->key)
        $typeKey = $entry->postType->key ?? 'page';
        $typeView = $this->typePrefix . $typeKey; // pages.types.page
        if (View::exists($typeView)) {
            return $typeView;
        }

        // 3) Дефолт
        return $this->default; // pages.show
    }
}
```

### Регистрация
В `AppServiceProvider@register`:
```php
$this->app->singleton(\App\Domain\View\TemplateResolver::class, function(){
    return new \App\Domain\View\BladeTemplateResolver(
        default: 'pages.show',
        overridePrefix: 'pages.overrides.',
        typePrefix: 'pages.types.',
    );
});
```

---

## Использование
В контроллерах (`PageController`, `HomeController`):
```php
$template = app(TemplateResolver::class)->forEntry($entry);
return view($template, ['entry' => $entry]);
```

---

## Структура view-файлов
```
resources/views/
 ├─ pages/
 │   ├─ show.blade.php                  # default
 │   ├─ overrides/
 │   │   └─ about.blade.php             # override по slug
 │   └─ types/
 │       ├─ page.blade.php              # для пост-типа page
 │       └─ news.blade.php              # для пост-типа news
```

---

## Тесты
### Unit (Resolver)
1. **Override выигрывает**:
   - `View::shouldReceive('exists')->with('pages.overrides.about')->andReturn(true);`
   - `forEntry(entry(slug='about', postType='page'))` → `pages.overrides.about`.
2. **Тип выигрывает над дефолтом**:
   - `exists('pages.overrides.x') => false`, `exists('pages.types.page') => true` → вернуть `pages.types.page`.
3. **Дефолт**: оба предыдущих отсутствуют → `pages.show`.

### Feature (сквозные)
4. **У PageController**: создать файлы `pages/types/page.blade.php` и `pages/show.blade.php`; проверить, что при отсутствии override рендерится по типу; при наличии `resources/views/pages/overrides/about.blade.php` — берётся он.
5. **На главной**: аналогично для `HomeController` (см. Задача 32).

---

## Приёмка (Definition of Done)
- [ ] Создан сервис `TemplateResolver` и реализация `BladeTemplateResolver`.
- [ ] Контроллеры используют сервис вместо хардкода имён view.
- [ ] Три сценария приоритета покрыты тестами.

---

## Расширение (out of scope)
- Override на уровне БД: поле `entries.template_override` и разрешение относительных путей.
- Поддержка тем: префикс `themes::{name}::` и каскад `theme > app`.
- Развилка по языкам/локалям: `pages/overrides/{locale}/{slug}`.
- Кеширование результата `forEntry()` (например, по `entry_id` + `updated_at`) с инвалидацией при изменении записи или деплое шаблонов.

