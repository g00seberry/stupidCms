# Задача 36. Cookie‑based JWT: модель токенов

## Резюме
Спроектировать и реализовать выпуск/проверку **access/refresh JWT** с хранением в **HttpOnly Secure** cookies (`cms_at`, `cms_rt`). Используем **асимметричную криптографию RS256** (RSA ключи) и `kid` для ротации. Сроки по умолчанию: `access=15 минут`, `refresh=30 дней`.

**Критерии приёмки:** сериализация (encode) и верификация (decode/verify) проходят юнит‑тесты для валидного/просроченного/подписанного неверным ключом токенов.

Связанные: 37 (login endpoint), 38 (refresh endpoint), 39 (logout/rotate), 27 (политики, доступ к API), 45 (кэш), 80 (аудит входов).

---

## Конфигурация `config/jwt.php`
```php
return [
    'algo' => 'RS256',
    'access_ttl' => 15 * 60,   // секунды
    'refresh_ttl' => 30 * 24 * 60 * 60,

    // Текущее значение key id (kid) — указывает, какой приватный ключ использовать для подписи
    'current_kid' => env('JWT_CURRENT_KID', 'v1'),

    // Карта ключей по kid
    'keys' => [
        // Пример: ключи хранятся файлами; можно хранить в env/Secrets Manager
        'v1' => [
            'private_path' => storage_path('keys/jwt-v1-private.pem'),
            'public_path'  => storage_path('keys/jwt-v1-public.pem'),
        ],
        // 'v2' => [...], // для ротации
    ],

    // Идентификаторы
    'issuer' => env('JWT_ISS', 'https://stupidcms.local'),
    'audience' => env('JWT_AUD', 'stupidcms-api'),

    // Имена cookies
    'cookies' => [
        'access'  => 'cms_at',
        'refresh' => 'cms_rt',
        'domain'  => env('SESSION_DOMAIN'),
        'secure'  => env('APP_ENV') !== 'local',
        'samesite'=> 'Strict',
        'path'    => '/',
    ],
];
```

### Генерация ключей (artisan)
Команда `cms:jwt:keys {kid}`:
```bash
php artisan cms:jwt:keys v1
```
Генерирует RSA‑пару (2048/3072) в `storage/keys/jwt-<kid>-private.pem` и `...public.pem`, проставляет права `600`.

---

## Пакет
Используем `firebase/php-jwt` (актуальная v6).
```bash
composer require firebase/php-jwt
```

---

## Структура claims
Минимальный payload:
- `iss` — issuer из конфига
- `aud` — audience из конфига
- `iat` — время выпуска (unix)
- `nbf` — не раньше (обычно = `iat`)
- `exp` — время истечения
- `jti` — уникальный id токена
- `sub` — id пользователя (строка)
- `typ` — `access` | `refresh`
- (`scp`) — опционально: список скоупов/ролей

В заголовке JWT:
- `alg = RS256`
- `kid = <current_kid>`
- `typ = 'JWT'`

---

## Сервис токенов
`app/Domain/Auth/JwtService.php`
```php
namespace App\Domain\Auth;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;
use Illuminate\Support\Str;
use Carbon\CarbonImmutable;

final class JwtService
{
    public function __construct(private array $config) {}

    public function issueAccessToken(int|string $userId, array $extra = []): string
    {
        return $this->encode($userId, 'access', $this->config['access_ttl'], $extra);
    }

    public function issueRefreshToken(int|string $userId, array $extra = []): string
    {
        return $this->encode($userId, 'refresh', $this->config['refresh_ttl'], $extra);
    }

    public function encode(int|string $userId, string $type, int $ttl, array $extra = []): string
    {
        $now = CarbonImmutable::now('UTC');
        $kid = $this->config['current_kid'];
        $paths = $this->config['keys'][$kid] ?? throw new \RuntimeException('Unknown kid');
        $private = file_get_contents($paths['private_path']);

        $payload = array_merge([
            'iss' => $this->config['issuer'],
            'aud' => $this->config['audience'],
            'iat' => $now->getTimestamp(),
            'nbf' => $now->getTimestamp(),
            'exp' => $now->addSeconds($ttl)->getTimestamp(),
            'jti' => (string) Str::uuid(),
            'sub' => (string) $userId,
            'typ' => $type,
        ], $extra);

        $headers = ['kid' => $kid, 'typ' => 'JWT'];
        return JWT::encode($payload, $private, $this->config['algo'], null, $headers);
    }

    /** @return array{claims:array, kid:string} */
    public function verify(string $jwt, ?string $expectType = null): array
    {
        $kid = $this->readKid($jwt) ?? $this->config['current_kid'];
        $paths = $this->config['keys'][$kid] ?? throw new \RuntimeException('Unknown kid');
        $public = file_get_contents($paths['public_path']);

        $decoded = JWT::decode($jwt, new Key($public, $this->config['algo']));
        $claims = json_decode(json_encode($decoded), true);

        if ($expectType && ($claims['typ'] ?? null) !== $expectType) {
            throw new \UnexpectedValueException('Unexpected token type');
        }
        if (($claims['iss'] ?? '') !== $this->config['issuer'] || ($claims['aud'] ?? '') !== $this->config['audience']) {
            throw new \UnexpectedValueException('Bad iss/aud');
        }
        return ['claims' => $claims, 'kid' => $kid];
    }

    private function readKid(string $jwt): ?string
    {
        [$h] = explode('.', $jwt, 2);
        $json = base64_decode(strtr($h, '-_', '+/'));
        $hdr = json_decode($json, true);
        return $hdr['kid'] ?? null;
    }
}
```

### Регистрация
В `AppServiceProvider@register`:
```php
$this->app->singleton(\App\Domain\Auth\JwtService::class, fn() => new \App\Domain\Auth\JwtService(config('jwt')));
```

---

## Cookie‑вспомогалки
`app/Support/JwtCookies.php`
```php
namespace App\Support;

use Symfony\Component\HttpFoundation\Cookie;

final class JwtCookies
{
    public static function access(string $jwt): Cookie
    {
        $c = config('jwt.cookies');
        $minutes = (int) ceil(config('jwt.access_ttl') / 60);
        return Cookie::create($c['access'], $jwt, now()->addMinutes($minutes))
            ->withSecure($c['secure'])
            ->withHttpOnly(true)
            ->withSameSite($c['samesite'])
            ->withPath($c['path'])
            ->withDomain($c['domain']);
    }
    public static function refresh(string $jwt): Cookie
    {
        $c = config('jwt.cookies');
        $minutes = (int) ceil(config('jwt.refresh_ttl') / 60);
        return Cookie::create($c['refresh'], $jwt, now()->addMinutes($minutes))
            ->withSecure($c['secure'])
            ->withHttpOnly(true)
            ->withSameSite($c['samesite'])
            ->withPath($c['path'])
            ->withDomain($c['domain']);
    }
}
```

---

## Юнит‑тесты (примеры)
```php
public function test_access_token_encode_and_verify()
{
    $svc = app(\App\Domain\Auth\JwtService::class);
    $jwt = $svc->issueAccessToken(123);

    $res = $svc->verify($jwt, 'access');
    $this->assertSame('123', $res['claims']['sub']);
}

public function test_expired_token_fails()
{
    $svc = app(\App\Domain\Auth\JwtService::class);
    $jwt = $svc->encode(1, 'access', -60); // истёк минута назад
    $this->expectException(\Firebase\JWT\ExpiredException::class);
    $svc->verify($jwt, 'access');
}

public function test_wrong_key_fails()
{
    // Сгенерировать второй keypair, подписать им, а в конфиге указать другой public -> verify бросает
    $this->expectException(\UnexpectedValueException::class);
    // ...
}
```

---

## Безопасность
- Cookies: `HttpOnly + Secure + SameSite=Strict + Path=/`.
- Refresh токен **никогда** не используется как bearer в заголовке.
- Ротация ключей: добавляем новую запись `keys[v2]`, меняем `current_kid` → новые токены подписываются новой парой, старые валидны до истечения.
- (Опционально) хранить **реестр отозванных refresh `jti`** в БД и проверять при `refresh`.

---

## Приёмка (Definition of Done)
- [ ] Конфиг `jwt.php`, ключи и artisan‑команда генерации.
- [ ] Сервис `JwtService` с выпуском/верификацией access/refresh.
- [ ] Cookie‑хелперы создают правильные cookies для ответа.
- [ ] Тесты подтверждают encode/verify и ошибки (expired, wrong key).

