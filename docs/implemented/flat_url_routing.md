# Плоская маршрутизация /{slug} (Задача 30)

## Обзор

Реализована плоская fallback-маршрутизация `/{slug}` для публичного сайта, которая обрабатывает опубликованные страницы типа `page` по их slug.

**Ключевые особенности:**
- Исключение зарезервированных путей через негативный lookahead в regex
- Case-insensitive обработка зарезервированных путей
- Запрет завершающих дефисов в slug
- Кэширование в `isReserved()` с автоматической инвалидацией при изменениях
- Единое название таблицы: `reserved_routes`
- CHECK-ограничение в БД для гарантии нормализации путей
- Канонизация URL (301 редиректы для lowercase и trailing slash)

## Основные компоненты

### 1. ReservedPattern

**Файл:** `app/Routing/ReservedPattern.php`

Класс для генерации регулярного выражения с негативным lookahead, исключающим зарезервированные пути из плоской маршрутизации.

**Методы:**
- `slugRegex(): string` - генерирует regex паттерн для Route::where()

**Особенности:**
- Собирает зарезервированные первые сегменты из:
  - `config('stupidcms.reserved_routes.paths')` (статические пути)
  - `config('stupidcms.reserved_routes.prefixes')` (статические префиксы)
  - `reserved_routes` (динамические резервации из БД, фильтр по `kind` в ['path', 'prefix'])
- Нормализует зарезервированные пути к нижнему регистру для case-insensitivity
- Строит негативный lookahead: `(?!^(?:admin|api|...)$)`
- **Строгий базовый паттерн**: `^[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$` (минимум 1 символ, ТОЛЬКО lowercase, БЕЗ trailing slash)
- Соответствует канону slug'ов из Task 21 (strictly lower, defense in depth)
- Middleware `CanonicalUrl` (глобальный) выполняет 301 редиректы ДО роутинга для uppercase/trailing slash

**Пример результата:**
```
^(?!^(?:admin|api)$)[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$
```

### 2. PageController

**Файл:** `app/Http/Controllers/PageController.php`

Контроллер для отображения публичных страниц по плоскому URL.

**Методы:**
- `show(string $slug): Response|View` - отображает опубликованную страницу по slug

**Логика:**
1. Дополнительная проверка `isReserved("/{$slug}")` для защиты от ложных срабатываний (на случай, если список зарезервированных изменился после `route:cache`)
2. Поиск опубликованной страницы типа `page` по slug
3. Возврат 404, если страница не найдена или не опубликована
4. Отображение view `pages.show` с данными Entry

### 3. Маршрут

**Файл:** `routes/web_content.php`

```php
Route::get('/{slug}', [PageController::class, 'show'])
    ->where('slug', ReservedPattern::slugRegex())
    ->name('page.show');
```

**Порядок загрузки:**
Маршрут загружается в `RouteServiceProvider` после core и плагинов, но до fallback:
1. Core routes (`routes/web_core.php`)
2. Admin API (`routes/api_admin.php`)
3. Plugin routes (`routes/plugins.php`)
4. **Content routes (`routes/web_content.php`)** ← здесь
5. Fallback (`FallbackController`)

### 4. Middleware (опционально)

**Файл:** `app/Http/Middleware/RejectReservedIfMatched.php`

Дополнительная защита от ложных срабатываний. Не используется по умолчанию, так как основная защита на уровне `ReservedPattern` и `PageController`.

## Критерии приёмки

✅ **Определён маршрут `/{slug}` с корректным regex**
- Маршрут зарегистрирован в `routes/web_content.php`
- Использует `ReservedPattern::slugRegex()` для исключения зарезервированных путей
- Regex паттерн: `^(?!^(?:admin|api|...)$)[a-z0-9][a-z0-9-]*$`

✅ **Зарезервированные пути не попадают в `PageController`**
- Статические пути из конфига (`admin`, `api`) исключены через негативный lookahead
- Динамические резервации из БД также исключены
- `PageController` дополнительно проверяет `isReserved()` для защиты от изменений после `route:cache`

✅ **`/` обслуживается Home и не конфликтует с `/{slug}`**
- Корневой `/` обрабатывается `HomeController` в `routes/web_core.php` (загружается раньше)
- `/{slug}` не перехватывает корневой путь

✅ **Тесты зелёные**
- 9 passed, 24 assertions

## Тесты

**Файл:** `tests/Feature/FlatUrlRoutingTest.php`

Покрывают:
1. ✅ Happy path: опубликованная страница отображается (`GET /about` → 200)
2. ✅ Зарезервированный путь `/admin` не попадает в `PageController` (404 от fallback)
3. ✅ Незарезервированный отсутствующий slug возвращает 404
4. ✅ Draft страница не отображается (404)
5. ✅ Страница с будущей датой публикации не отображается (404)
6. ✅ Корневой `/` не конфликтует с `/{slug}` (обрабатывается `HomeController`)
7. ✅ Кеш роутов: порядок сохраняется после `route:cache`
8. ✅ Динамически зарезервированный путь не попадает в `PageController` (404)
9. ✅ Похожий slug (например, `/admin1`) не блокируется негативным lookahead (только точные совпадения)

## Особенности реализации

### Regex паттерн

Паттерн генерируется при загрузке роутов (при `route:cache` список фиксируется до следующего деплоя/инвалидации). Это приемлемо, так как:
- Плагины/система регистрируют свои конкретные роуты раньше и перехватят свои пути
- `PageController` дополнительно проверяет `isReserved()` для защиты от изменений после кеширования

**Запрет завершающего дефиса:**
- Паттерн `[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$` запрещает slug типа `about-`
- Первый и последний символ должны быть буквой или цифрой

**Case-insensitive резервирование:**
- Зарезервированные пути приводятся к нижнему регистру при построении regex (`Admin` = `ADMIN` = `admin`)
- Это обеспечивает единообразную обработку независимо от регистра в конфиге или БД

### Нормализация путей

- Все пути нормализуются через `PathNormalizer::normalize()` (trim, lowercase, NFC, удаление query/fragment)
- Первый сегмент извлекается через `Str::before($path, '/')`
- Зарезервированные пути приводятся к нижнему регистру для case-insensitivity (`Admin` = `ADMIN` = `admin`)

### Дополнительная защита

**Ключевой инвариант (single source of truth):**

`PageController` проверяет `isReserved("/{$slug}")` перед поиском Entry. Это защита на случай, если:
- Список зарезервированных изменился после `route:cache`
- Динамическая резервация была добавлена после кеширования роутов

**Как это работает:**
- Regex-паттерн генерируется при загрузке роутов и фиксируется при `route:cache`
- `PageController` всегда проверяет актуальное состояние через `isReserved()` (с кэшем 60 сек)
- При изменении резерваций (`reservePath()`, `releasePath()`, `releaseBySource()`) кэш автоматически инвалидируется

**Оптимизация производительности:**
- Метод `isReserved()` использует кэширование списка первых сегментов (TTL 60 сек)
- Сначала проверяется первый сегмент через кэш (быстрая проверка без запроса к БД)
- Если первый сегмент заблокирован, выполняется проверка полного пути в БД
- Кэш автоматически сбрасывается после любого изменения резерваций
- Это снижает нагрузку на БД при частых проверках в `PageController`

### Обработка исключений

`PageController` обрабатывает `QueryException` и `PDOException` на случай отсутствия таблицы `reserved_routes` в тестах или при миграциях.

## Производительность

- Простой lookup по slug (индекс) + один запрос к БД
- Regex паттерн генерируется один раз при загрузке роутов
- **Кэширование в `isReserved()`:** 
  - Список первых сегментов кэшируется на 60 секунд для снижения нагрузки на БД
  - Кэш автоматически инвалидируется при любом изменении резерваций (`Cache::forget()`)
  - Это обеспечивает актуальность данных при изменениях без задержки в 60 сек
- Допускается HTTP-кеш на ответы `PageController` (public, условно по ETag)

## Совместимость

- Slug ASCII — совместим с генератором из задачи 21
- Формат slug: `^[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$` (минимум 1 символ, без завершающего дефиса)
- Запрещены подряд двойные дефисы — не ограничиваем на уровне роутинга; это задача генерации/валидации slug

---

## Результаты тестов

**FlatUrlRoutingTest:** 12 passed, 32 assertions
**Всего:** 185 passed, 1 skipped (428 assertions)

---

## Миграции базы данных

**Создание таблицы:**
- `2025_11_06_000070_create_reserved_routes_table.php` — создает таблицу `reserved_routes` с правильной структурой

**Особенности миграции:**
- Таблица создается сразу с правильной структурой, без необходимости переименования или изменения типов полей
- Поле `source` имеет тип `VARCHAR(100)` (не enum), что позволяет использовать формат `'system:name'`, `'plugin:name'`, `'module:name'`
- Поле `kind` имеет тип `ENUM('prefix', 'path')` с default `'path'` для различения типов резервации

**Структура таблицы `reserved_routes`:**
- `id` BIGINT PK
- `path` VARCHAR(255) UNIQUE — канонический путь в нижнем регистре (нормализуется через `PathNormalizer`)
- `kind` ENUM('prefix', 'path') DEFAULT 'path' — тип резервации:
  - `'path'` — точный путь (например, `/admin`)
  - `'prefix'` — префикс пути (например, `/api/*`)
- `source` VARCHAR(100) — источник резервирования (system:name, plugin:name, module:name)
- `created_at`, `updated_at` TIMESTAMP
- Индекс на `source` для быстрого освобождения по источнику (например, при удалении плагина)

---

## Связанные задачи

- Задача 23: Reserved routes
- Задача 26: Home `/`
- Задача 27: Policies
- Задача 28: Сервис резервирования путей
- Задача 29: Порядок роутинга
- Задача 31: PageController@show (детальная реализация)

