# Задача 28. Сервис резервирования путей

## Резюме
Нужен сервис, позволяющий **динамически резервировать URL-пути** (например, плагинами или системными модулями), чтобы контент/роуты CMS не могли занять эти адреса. Ключевой API: `reservePath($path, $source)` и методы для проверки/освобождения.

**Критерии приёмки:** повторная попытка зарезервировать уже занятый путь (кем угодно) приводит к исключению/422.

Связанные задачи: 23 (валидатор `reserved_routes`), 29 (порядок роутинга), 27 (политики), 50 (Admin API Settings), 93 (Redirects).

---

## Терминология
- **Путь** — абсолютный URL-путь с ведущим слэшем, без домена, без query/fragment. Примеры: `/admin`, `/feed.xml`, `/sitemap.xml`.
- **Источник (source)** — строковый идентификатор владельца резервирования. Формат: `system:<name>` или `plugin:<name>` или `module:<name>`.

---

## Схема данных
Таблица `route_reservations`:
- `id` BIGINT PK
- `path` VARCHAR(255) **в канонической форме** (см. нормализацию)
- `source` VARCHAR(100) **кто** забронировал (например, `plugin:shop`)
- `reason` VARCHAR(255) NULL (необязательно)
- `created_at`, `updated_at`

Индексы и ограничения:
- `UNIQUE(path)` — путь уникален глобально (гарантирует «повторный резерв → ошибка»).
- `INDEX(source)` — для быстрого освобождения по источнику.

> **Примечание о регистре**: путь хранится **в нижнем регистре**; сравнение — case-insensitive. Для надёжности канонизируем до lower-case + NFC.

---

## Нормализация пути
`PathNormalizer::normalize(string $raw): string`
- trim пробелы
- взять часть **до** `?` и `#`
- гарантировать ведущий `/`
- убрать trailing `/` (кроме корня `/`)
- `mb_strtolower`
- Unicode NFC

Ошибочные значения (`''`, `'#'`, `'?'`) → `InvalidPathException`.

---

## Контракт сервиса
```php
namespace App\Domain\Routing;

use Illuminate\Support\Facades\DB;

interface PathReservationService
{
    /** Пробует зарезервировать путь. Если уже занят — бросает PathAlreadyReservedException. */
    public function reservePath(string $path, string $source, ?string $reason = null): void;

    /** Снять резерв у конкретного пути, если он принадлежит источнику; иначе — бросает ForbiddenReservationRelease. */
    public function releasePath(string $path, string $source): void;

    /** Освободить все пути данного источника. */
    public function releaseBySource(string $source): int;

    /** Проверить, забронирован ли путь (с учётом статических из config). */
    public function isReserved(string $path): bool;

    /** Вернуть владельца (или null). */
    public function ownerOf(string $path): ?string;
}
```

### Исключения
- `PathAlreadyReservedException` (включает `path`, `owner`)
- `InvalidPathException`
- `ForbiddenReservationRelease` (когда чужая бронь)

---

## Реализация (эскиз)
```php
final class PathReservationServiceImpl implements PathReservationService
{
    public function __construct(private PathReservationStore $store, private array $static) {}

    public function reservePath(string $path, string $source, ?string $reason = null): void
    {
        $p = PathNormalizer::normalize($path);
        // Блок для статического списка — никогда нельзя резервировать
        if (in_array($p, $this->static, true)) {
            throw new PathAlreadyReservedException($p, 'static:config');
        }
        // Попытка вставки с уникальным индексом
        try {
            $this->store->insert($p, $source, $reason);
        } catch (\Illuminate\Database\QueryException $e) {
            if ($this->store->isUniqueViolation($e)) {
                $owner = $this->store->ownerOf($p) ?? 'unknown';
                throw new PathAlreadyReservedException($p, $owner);
            }
            throw $e;
        }
    }

    public function releasePath(string $path, string $source): void
    {
        $p = PathNormalizer::normalize($path);
        $owner = $this->store->ownerOf($p);
        if ($owner && $owner !== $source) {
            throw new ForbiddenReservationRelease($p, $owner, $source);
        }
        $this->store->delete($p);
    }

    public function releaseBySource(string $source): int
    { return $this->store->deleteBySource($source); }

    public function isReserved(string $path): bool
    { $p = PathNormalizer::normalize($path); return in_array($p, $this->static, true) || $this->store->exists($p); }

    public function ownerOf(string $path): ?string
    { return $this->store->ownerOf(PathNormalizer::normalize($path)); }
}
```

### Хранилище
```php
interface PathReservationStore
{
    public function insert(string $path, string $source, ?string $reason): void;
    public function delete(string $path): void;
    public function deleteBySource(string $source): int;
    public function exists(string $path): bool;
    public function ownerOf(string $path): ?string;
    public function isUniqueViolation(\Throwable $e): bool;
}
```

---

## Интеграции
- **Config**: `config/reserved_routes.php` (статические зарезервированные пути, см. Задача 23).
- **Валидатор слугов/роутов**: при генерации/сохранении slug проверять `PathReservationService::isReserved('/'.$slug)` → `422` с сообщением.
- **Плагины**: при `boot()` плагина резервируют свои пути: `reservePath('/shop', 'plugin:shop')`. При `disable`/`uninstall` — `releaseBySource('plugin:shop')`.
- **События**: `PluginDisabled($name)` → Listener вызывает `releaseBySource("plugin:$name")`.

---

## HTTP/Админ API (минимум)
- `POST /api/admin/reservations` → `reservePath`
- `DELETE /api/admin/reservations/{path}` → `releasePath`
- Защита: только администратор (см. Задача 27, политики).

Формат ошибок: RFC 7807 (`type`, `title`, `status`, `detail`). Для `PathAlreadyReservedException` — `409 Conflict`.

---

## CLI
```bash
php artisan routes:reserve /feed.xml system:feeds "RSS feed"
php artisan routes:release /feed.xml system:feeds
php artisan routes:list-reservations
```

---

## Тесты (PHPUnit)
1. **Успех**: `reservePath('/admin', 'system:core')` создаёт запись.
2. **Повтор**: повторный вызов `reservePath('/admin', 'system:core')` → `PathAlreadyReservedException` (критерий приёмки).
3. **Чужая бронь**: `reserve('/a','plugin:x'); releasePath('/a','plugin:y')` → `ForbiddenReservationRelease`.
4. **Нормализация**: `'/Admin/'` и `'/admin'` — один путь; вставка второго — конфликт.
5. **Статическая бронь**: если в `config/reserved_routes` есть `/login`, попытка `reserve('/login', 'plugin:x')` → ошибка.
6. **Plugin disable**: `reserve('/shop','plugin:shop')`; диспатч `PluginDisabled('shop')` → запись удалена.

---

## Приёмка (Definition of Done)
- [ ] Таблица `route_reservations` и репозиторий/сервис реализованы.
- [ ] API `reservePath($path,$source)` бросает ошибку при повторном резерве.
- [ ] Интеграция с валидаторами слугов и статическим конфигом.
- [ ] Освобождение срабатывает при выключении плагина.
- [ ] Тесты выше зелёные.

---

## Расширение (out of scope)
- Резервирование **префикса** (`/admin/*`). Возможный дизайн: отдельная таблица `route_prefix_reservations` и проверка `Str::startsWith()`.
- Срок действия резерва (TTL) — добавление `expires_at` и чистилка.
- Валидация по HTTP-методу (GET-only vs POST-only).

