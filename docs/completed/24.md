# Задача 24. Обновление истории слугов

## Резюме
Обеспечить автоматическое ведение истории значений `slug` для записей (`entries`) в таблице `entry_slugs` так, чтобы после любого изменения слуга у записи **ровно один** слуг имел флаг `is_current = true`. История используется для аналитики и (через плагин Redirects) для авто-301 со старых адресов.

## Связанные задачи и зависимости
- 21 — Транслитерация RU→lat (источник значения slug).
- 22 — Уникальность slug среди Pages (валидатор на запись).
- 23 — Конфликты с `reserved_routes` (валидатор на запись).
- 93 — Интеграция с Redirects (реагирует на событие смены слуга).

## Схема данных
Таблица `entry_slugs` (уже создана в миграции 17):
- `entry_id` (FK → `entries.id`, `on delete cascade`)
- `slug` (varchar)
- `is_current` (tinyint bool)
- `created_at` (timestamp)

Индексы:
- PK `(entry_id, slug)` — предотвращает дублирование одной и той же пары.
- IDX `(entry_id, is_current)` — быстрый поиск текущего слуга для записи.

> Замечание: **частный** уникальный индекс по `(entry_id) WHERE is_current=1` в MySQL недоступен. Инвариант «ровно один текущий» обеспечиваем приложением в транзакции.

## Инварианты
1. Для каждой записи `entries.id = E` существует **не более одного** ряда `entry_slugs` с `(entry_id = E AND is_current = 1)`.
2. При создании записи первый слуг фиксируется в истории с `is_current = 1`.
3. При изменении `entries.slug` предыдущая запись истории помечается `is_current = 0`, новая — `is_current = 1`.
4. Возврат к одному из прошлых слугов не создаёт дубликат (обновляется существующая строка, становится `is_current = 1`).

## Контракты
### Сервис `EntrySlugService`
```php
interface EntrySlugService
{
    /** Создать текущую запись истории (после создания Entry). */
    public function onCreated(Entry $entry): void;

    /** Синхронизировать историю при изменении slug. Возвращает true, если slug сменился. */
    public function onUpdated(Entry $entry, string $oldSlug): bool;

    /** Получить текущий слуг для Entry. */
    public function currentSlug(int $entryId): ?string;
}
```

### События
- `EntrySlugChanged { int $entryId; string $old; string $new; }` — диспатчится при фактической смене слуга (используется плагином Redirects).

## Точки интеграции (обсервер)
Регистрируем `EntryObserver`:
- `created(Entry $e)` → `EntrySlugService::onCreated($e)`.
- `updated(Entry $e)` → если `$e->wasChanged('slug')`, вызвать `onUpdated($e, $e->getOriginal('slug'))`.

Регистрация в `AppServiceProvider` или отдельном `EventServiceProvider`.

## Алгоритмы (псевдокод)
### onCreated
```
DB::transaction(function(){
  UPSERT entry_slugs (entry_id, slug) VALUES (E.id, E.slug)
    ON DUPLICATE KEY UPDATE is_current = VALUES(is_current);
  UPDATE entry_slugs SET is_current = 0 WHERE entry_id = E.id AND slug <> E.slug AND is_current = 1;
  UPDATE entry_slugs SET is_current = 1 WHERE entry_id = E.id AND slug = E.slug;
});
```
> Примечание: двойной апдейт безопасен и идемпотентен. Можно выполнить одним выражением с upsert и последующим `UPDATE ... WHERE is_current=1 AND slug<>?`.

### onUpdated
```
if (oldSlug === E.slug) return false;
DB::transaction(function(){
  // Снять текущий флаг у всех старых
  UPDATE entry_slugs SET is_current = 0 WHERE entry_id = E.id AND is_current = 1;

  // Поднять/создать запись для нового слуга
  INSERT INTO entry_slugs(entry_id, slug, is_current, created_at)
    VALUES (E.id, E.slug, 1, now())
  ON DUPLICATE KEY UPDATE is_current = 1;
});

dispatch(new EntrySlugChanged(E.id, oldSlug, E.slug));
return true;
```

### Конкурентность
- Оборачиваем операции в `DB::transaction()`.
- Во время переключения «текущего» используем один `UPDATE` по `entry_id` (атомарно снимает флаги), затем upsert — это гарантирует, что итогом будет ровно один `is_current=1`.
- При высоких коллизиях допускается добавление `SELECT ... FOR UPDATE` по агрегирующей строке `entries.id` (lock по родительской записи), чтобы сериализовать смены слуга одной записи.

## Обработка спец-случаев
- **Восстановление soft-deleted Entry**: история не меняется; текущий слуг остаётся прежним.
- **Повторное присвоение старого слуга**: не создаём новую строку, upsert делает `is_current=1` для существующей.
- **Импорт/сид**: команда backfill (см. ниже) создаёт недостающие текущие строки.

## Команда backfill
CLI-команда `cms:slugs:backfill`:
- Проходит по всем `entries` батчами.
- Для каждой записи проверяет наличие `entry_slugs(entry_id = E.id AND slug = E.slug)`.
- Если нет — создаёт; гарантирует единственность `is_current = 1` по алгоритму выше.

## Тесты (PHPUnit)
1. **Создание**: после `Entry::create` в `entry_slugs` ровно одна строка `is_current=1` с текущим slug.
2. **Смена слуга**: было `about` → стало `about-us`: старая строка существует `is_current=0`, новая — `is_current=1`.
3. **Возврат к прежнему**: `about-us` → `about`: строка с `about` переключена в `is_current=1`, новых рядов не добавлено.
4. **Событие**: при смене слуга диспатчится `EntrySlugChanged` с корректными значениями.
5. **Конкурентность**: два параллельных апдейта на одну запись заканчиваются ровно одним `is_current=1` (интеграционный тест с транзакциями/locks, если возможно).
6. **Backfill**: запуск команды создаёт отсутствующие текущие строки и чинит множественные `is_current=1`.

## Приёмка (готовность к «OK»)
- [ ] Обсерверы подключены и покрыты тестами.
- [ ] Сервис `EntrySlugService` реализован, публичные методы задокументированы.
- [ ] Все тесты из списка зелёные.
- [ ] На любой записи после изменения слуга в `entry_slugs` **ровно один** ряд с `is_current=true`.
- [ ] Событие `EntrySlugChanged` диспатчится один раз на смену.

## Ошибки и логирование
- Ошибки уровня БД (duplicate key, FK) пробрасываются; транзакции откатываются.
- В аудит-лог (таблица `audits`) пишем действие `entry.slug_changed` c `old/new`.

## Документация для API/админки
- **API**: Без изменений эндпоинтов; история — внутренний механизм. Админ-эндпоинт (р/o) для истории можно добавить позднее.
- **UI**: В карточке записи (опционально) вывести «История URL» (read-only список с датами).

