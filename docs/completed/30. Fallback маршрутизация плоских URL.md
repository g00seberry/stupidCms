# Задача 30. Fallback маршрутизация плоских URL

## Резюме
Настроить плоскую fallback-маршрутизацию `/{slug}` для публичного сайта:
- Плоский slug **без слешей** (только `a-z0-9-`).
- Исключить зарезервированные пути (статические и динамические из сервиса резервирования).
- Корневой `/` обслуживается Home (см. Задача 26) и **не** относится к этому маршруту.

**Критерии приёмки:**
- `GET /about` — отдаёт контент cо страницей (если есть published Entry со slug `about`).
- `GET /admin` — **не попадает** в этот маршрут (обрабатывается core-роутами или даёт 404 через fallback), но не `PageController`.

Связанные: 23 (reserved routes), 26 (Home `/`), 27 (Policies), 28 (Сервис резервирования путей), 29 (Порядок роутинга), 31 (PageController@show).

---

## Порядок маршрутов
В `RouteServiceProvider` (см. Задача 29) маршруты грузятся: **core → plugins → content → fallback**. Плоский `/{slug}` находится в `routes/web_content.php` **после** core и плагинов, но **до** общего `Route::fallback`.

---

## Регулярное выражение slug
ASCII-слуг из задачи 21: `^[a-z0-9][a-z0-9-]*$` (минимум 1 символ).

Допуски:
- запрещены подряд двойные дефисы — **не** ограничиваем на уровне роутинга; это задача генерации/валидации слуга.

---

## Исключение зарезервированных путей
На этапе регистрации маршрутов строим негативное совпадение (negative lookahead) по списку зарезервированных **первых сегментов**.

Источник списка:
- `config('reserved_routes.paths')` (статические),
- `route_reservations` (динамические, см. Задача 28) — берём **только** первый сегмент.

Пример провайдера для генерации паттерна:
```php
namespace App\Routing;

use Illuminate\Support\Str;
use Illuminate\Support\Facades\DB;

final class ReservedPattern
{
    public static function slugRegex(): string
    {
        $static = collect((array) config('reserved_routes.paths', []))
            ->map(fn($p) => trim(parse_url($p, PHP_URL_PATH) ?: '/', '/'))
            ->filter()->map(fn($s) => Str::before($s, '/'));

        $dynamic = DB::table('route_reservations')
            ->select('path')->pluck('path')
            ->map(fn($p) => trim(parse_url($p, PHP_URL_PATH) ?: '/', '/'))
            ->filter()->map(fn($s) => Str::before($s, '/'));

        $blocked = $static->merge($dynamic)
            ->unique()->filter()->map(fn($s) => preg_quote($s, '#'))
            ->implode('|');

        $neg = $blocked ? "(?!^(?:{$blocked})$)" : '';
        return "{$neg}^[a-z0-9][a-z0-9-]*$";
    }
}
```

> При `route:cache` список фиксируется до следующего деплоя/инвалидации. Это приемлемо, так как сами плагины/система регистрируют свои конкретные роуты раньше и перехватят свои пути.

---

## Определение маршрута
`routes/web_content.php`:
```php
use App\Http\Controllers\PageController;
use App\Routing\ReservedPattern;
use Illuminate\Support\Facades\Route;

Route::get('/{slug}', [PageController::class, 'show'])
    ->where('slug', ReservedPattern::slugRegex())
    ->name('page.show');
```

Корневой `/` объявлен в `routes/web_core.php` и идёт раньше.

---

## Защита от ложных срабатываний
Дополнительно можно поставить middleware `RejectReservedIfMatched`, который при совпадении по пути `/{slug}` проверит `PathReservationService::isReserved("/{$slug}")` и выполнит `abort(404)`. Это защита на случай, если список зарезервированных изменился **после** кеширования роутов.

---

## Тесты (Feature)
1. **Happy path**: создать Entry со slug `about`, статус `published`, `published_at <= now()`. `GET /about` → 200 и тело содержит заголовок страницы.
2. **`/admin`**: убедиться, что в core есть маршрут `/admin/ping`. `GET /admin` → **не** вызывает `PageController@show` (assert Controller Action не равен PageController) и отдаёт 200/redirect/403 в зависимости от админки. Если `/admin` не определён, то `GET /admin` → 404 от `fallback`, а не `PageController`.
3. **Незарезервированный отсутствующий**: `GET /nonexistent` → 404 (после работы PageController — см. Задачу 31) или общий fallback (если контроллер вернёт 404).
4. **Кеш роутов**: `artisan route:cache`; повторить тесты 1–3.

---

## Приёмка (Definition of Done)
- [ ] Определён маршрут `/{slug}` с корректным regex.
- [ ] Зарезервированные пути не попадают в `PageController`.
- [ ] `/` обслуживается Home и не конфликтует с `/{slug}`.
- [ ] Тесты выше зелёные.

---

## Нефункциональные
- Производительность: простой lookup по slug (индекс) + один запрос.
- Совместимость: slug ASCII — совместим с генератором из задачи 21.
- Кэш: допускается HTTP-кеш на ответы PageController (public, условно по ETag).

